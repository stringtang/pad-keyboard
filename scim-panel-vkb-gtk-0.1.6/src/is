/*
 * scim-panel-vkb-gtk.cpp : scim panel with vkb embedded
 *
 * Copyright (c) 2002-2005 James Su <suzhe@tsinghua.org.cn>
 * Copyright (C) 2009, Intel Corporation.
 *
 * Author: Raymond Liu <raymond.liu@intel.com>
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 * 
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */


#include <sys/wait.h>
#include <sys/types.h>
#include <sys/time.h>
#include <signal.h>
#include <unistd.h>
#include <errno.h>
#include <glib.h>
#include <gdk/gdk.h>
#ifdef GDK_WINDOWING_X11
#include <gdk/gdkx.h>
#endif
#include <gtk/gtk.h>
#include <stdlib.h>
#include <list>

#include <map>

#include <dbus/dbus.h>
#include <dbus/dbus-glib.h>
#include <string.h>
#include <iostream>
#define Uses_C_STDIO
#define Uses_C_STDLIB
#define Uses_SCIM_LOOKUP_TABLE
#define Uses_SCIM_SOCKET
#define Uses_SCIM_TRANSACTION
#define Uses_SCIM_TRANS_COMMANDS
#define Uses_SCIM_CONFIG
#define Uses_SCIM_CONFIG_MODULE
#define Uses_SCIM_DEBUG
#define Uses_SCIM_HELPER
#define Uses_SCIM_HELPER_MODULE
#define Uses_SCIM_PANEL_AGENT
#define Uses_SCIM_PROPERTY
#define Uses_SCIM_IMENGINE
#define Uses_SCIM_COMPOSE_KEY
#define Uses_SCIM_CONFIG_PATH
#define Uses_SCIM_CONFIG_BASE

#include "../config.h"
#include <scim.h>
#include <gtk/scimstringview.h>

#include "panel_private.h"
#include "panel-settings.h"
#include "panel-keyboard.h"
#include "panel-utility.h"

#include "panel-vkb-dbusobj.h"
#include "data/icons/left.xpm"
#include "data/icons/right.xpm"
#include "data/icons/help.xpm"
#include "data/icons/hide.xpm"
#include "data/icons/trademark.xpm"
#include "data/icons/menu.xpm"

using namespace scim;

#define SCIM_KEYBOARD_ICON_FILE     (SCIM_ICONDIR "/keyboard.png")
#define SCIM_TRADEMARK_ICON_FILE    (SCIM_ICONDIR "/trademark.png")
#define SCIM_SETUP_ICON_FILE        (SCIM_ICONDIR "/setup.png")
#define SCIM_HELP_ICON_FILE         (SCIM_ICONDIR "/help.png")
#define SCIM_HIDE_ICON_FILE         (SCIM_ICONDIR "/hide.png")
#define SCIM_MENU_ICON_FILE         (SCIM_ICONDIR "/menu.png")
#define SCIM_UP_ICON_FILE           (SCIM_ICONDIR "/up.png")
#define SCIM_DOWN_ICON_FILE         (SCIM_ICONDIR "/down.png")
#define SCIM_LEFT_ICON_FILE         (SCIM_ICONDIR "/left.png")
#define SCIM_RIGHT_ICON_FILE        (SCIM_ICONDIR "/right.png")

#define TOOLBAR_ICON_SIZE                     32 
#define TRAY_ICON_SIZE                        32
#define LOOKUP_ICON_SIZE                      32
#define SMALL_TOOLBAR_ICON_SIZE                     16
#define SMALL_TRAY_ICON_SIZE                        18
#define SMALL_LOOKUP_ICON_SIZE                      12

// this is the original
//#define LOOKUP_TABLE_MIN_HEIGHT                     66
// this is my modify
#define LOOKUP_TABLE_MIN_HEIGHT                     33

#define PANEL_DEFAULT_TRIGER_DELAY              70
static guint triger_delay_timeout_id = 0;
static guint triger_delay = PANEL_DEFAULT_TRIGER_DELAY;
static gboolean triger_on;

/////////////////////////////////////////////////////////////////////////////
// Declaration of internal data types.
/////////////////////////////////////////////////////////////////////////////
struct PropertyInfo {
    Property   property;
    GtkWidget *widget;

    PropertyInfo () : widget (0) { }
};

typedef std::vector <PropertyInfo>               PropertyRepository;

struct HelperPropertyInfo {
    GtkWidget           *holder;
    PropertyRepository   repository;

    HelperPropertyInfo () : holder (0) { }
};

#if SCIM_USE_STL_EXT_HASH_MAP
typedef __gnu_cxx::hash_map <int, HelperPropertyInfo, __gnu_cxx::hash <int> > HelperPropertyRepository;
typedef __gnu_cxx::hash_map <String, std::vector <size_t>, scim_hash_string>  MapStringVectorSizeT;
#elif SCIM_USE_STL_HASH_MAP
typedef std::hash_map <int, HelperPropertyInfo, std::hash <int> >             HelperPropertyRepository;
typedef std::hash_map <String, std::vector <size_t>, scim_hash_string>        MapStringVectorSizeT;
#else
typedef std::map <int, HelperPropertyInfo>                                    HelperPropertyRepository;
typedef std::map <String, std::vector <size_t> >                              MapStringVectorSizeT;
#endif

/////////////////////////////////////////////////////////////////////////////
// Declaration of internal functions.
/////////////////////////////////////////////////////////////////////////////
static void       ui_config_reload_callback            (const ConfigPointer &config);
static void       ui_load_config                       (void);
static void       ui_initialize                        (void);

static void       ui_settle_input_window               (bool            relative = false,
                                                        bool            force    = false);
static void       ui_settle_toolbar_window             (bool            force    = false);

static int        ui_screen_width                      (void);
static int        ui_screen_height                     (void);
static void       ui_get_workarea                      (int            &x,
                                                        int            &y,
                                                        int            &width,
                                                        int            &height);

#if ENABLE_TRAY_ICON
static gboolean   ui_create_tray_icon_when_idle        (gpointer        data);
#endif

#if GDK_MULTIHEAD_SAFE
static void       ui_switch_screen                     (GdkScreen      *screen);
#endif

static GdkPixbuf* ui_scale_pixbuf                      (GdkPixbuf      *pixbuf,
                                                        int             width,
                                                        int             height);

static GtkWidget* ui_create_label                      (const String   &name,
                                                        const String   &iconfile,
                                                        const char    **xpm,
                                                        bool            show_icon_only = false,
                                                        bool            force_icon = false);

static GtkWidget* ui_create_icon                       (const String   &iconfile,
                                                        const char    **xpm = NULL,
                                                        int             width = -1,
                                                        int             height = -1,
                                                        bool            force_create = false);

static GtkWidget* ui_create_trademark_icon             (void);
static GtkWidget* ui_create_help_icon                  (void);
static GtkWidget* ui_create_hide_icon                  (void);
static GtkWidget* ui_create_menu_icon                  (void);
static GtkWidget* ui_create_left_icon                  (void);
static GtkWidget* ui_create_right_icon                 (void);

/*static GtkWidget* ui_create_factory_menu_entry         (const PanelFactoryInfo &info,
                                                        int                    id,
                                                        GtkMenuShell           *menu,
                                                        bool                   show_lang,
                                                        bool                   show_name);
*/
// callback functions
static void       ui_preedit_area_move_cursor_cb       (ScimStringView *view,
                                                        guint           position);

static void       ui_help_button_click_cb              (GtkButton      *button,
                                                        gpointer        user_data);
static void       ui_menu_button_click_cb              (GtkButton      *button,
                                                        gpointer        user_data);
static gboolean   ui_factory_button_released_cb  (GtkWidget      *button,
                                                        GdkEvent       *event,
                                                        gpointer        user_data);
//static gboolean   ui_factory_button_click_cb           (GtkWidget      *button,
  //                                                     gpointer        user_data);
//static void       ui_factory_menu_activate_cb          (GtkMenuItem    *item,
  //                                                      gpointer        user_data);
//static void       ui_factory_menu_deactivate_cb        (GtkMenuItem    *item,
                                                        //gpointer        user_data);


static void       ui_lookup_table_horizontal_click_cb  (GtkWidget      *item,
                                                        guint           position);

static void       ui_lookup_table_up_button_click_cb   (GtkButton      *button,
                                                        gpointer        user_data);
static void       ui_lookup_table_down_button_click_cb (GtkButton      *button,
                                                        gpointer        user_data);
static gboolean   ui_input_window_motion_cb            (GtkWidget      *window,
                                                        GdkEventMotion *event,
                                                        gpointer        user_data);
static gboolean   ui_input_window_click_cb             (GtkWidget      *window,
                                                        GdkEventButton *event,
                                                        gpointer        user_data);
static gboolean   ui_toolbar_window_crossing_cb        (GtkWidget      *window,
                                                        GdkEventCrossing *event,
                                                        gpointer        user_data);
static gboolean   ui_toolbar_window_motion_cb          (GtkWidget      *window,
                                                        GdkEventMotion *event,
                                                        gpointer        user_data);
static gboolean   ui_toolbar_window_click_cb           (GtkWidget      *window,
                                                        GdkEventButton *event,
                                                        gpointer        user_data);
static void       ui_turn_off_panel                    (GtkButton      *button,
                                                        gpointer        user_data);
static gboolean   ui_hide_window_timeout_cb            (gpointer data);

static void       ui_command_menu_reload_activate_cb   (GtkMenuItem    *item,
                                                        gpointer        user_data);
static void       ui_command_menu_help_activate_cb     (GtkMenuItem    *item,
                                                        gpointer        user_data);
static void       ui_command_menu_helper_activate_cb   (GtkWidget      *item,
                                                        gpointer        user_data);
static void       ui_command_menu_deactivate_cb        (GtkWidget      *item,
                                                        gpointer        user_data);

#if ENABLE_TRAY_ICON
static void       ui_tray_icon_destroy_cb              (GtkObject      *object,
                                                        gpointer        user_data);
#endif

// Client Property Callback
static void       ui_property_activate_cb              (GtkWidget      *widget,
                                                        gpointer        user_data);

static void       ui_property_menu_deactivate_cb       (GtkWidget      *item,
                                                        gpointer        user_data);

static bool       ui_can_hide_input_window             (void);

static bool       ui_any_menu_activated                (void);

static void       ui_show_help                         (const String   &help);

static PangoAttrList * create_pango_attrlist           (const String    &str,
                                                        const AttributeList &attrs);

// Action function
static void       action_request_help                  (void);
static void       action_show_command_menu             (void);

// PanelAgent related functions
static bool       initialize_panel_agent               (const String &config, const String &display, bool resident);
static bool       run_panel_agent                      (void);
static gpointer   panel_agent_thread_func              (gpointer data);
static void       start_auto_start_helpers             (void);
                  
static void       slot_transaction_start               (void);
static void       slot_transaction_end                 (void);
static void       slot_reload_config                   (void);
static void       slot_turn_on                         (void);
static void       slot_turn_off                        (void);
static void       slot_update_screen                   (int screen);
static void       slot_update_spot_location            (int x, int y);
static void       slot_update_factory_info             (const PanelFactoryInfo &info);
static void       slot_show_help                       (const String &help);
static void       slot_show_factory_menu               (const std::vector <PanelFactoryInfo> &menu);
                  
static void       slot_show_preedit_string             (void);
static void       slot_show_aux_string                 (void);
static void       slot_show_lookup_table               (void);
static void       slot_hide_preedit_string             (void);
static void       slot_hide_aux_string                 (void);
static void       slot_hide_lookup_table               (void);
static void       slot_update_preedit_string           (const String &str, const AttributeList &attrs);
static void       slot_update_preedit_caret            (int caret);
static void       slot_update_aux_string               (const String &str, const AttributeList &attrs);
static void       slot_update_lookup_table             (const LookupTable &table);
static void       slot_register_properties             (const PropertyList &props);
static void       slot_update_property                 (const Property &prop);
                  
static void       slot_register_helper_properties      (int id, const PropertyList &props);
static void       slot_update_helper_property          (int id, const Property &prop);
static void       slot_register_helper                 (int id, const HelperInfo &helper);
static void       slot_remove_helper                   (int id);
static void       slot_lock                            (void);
static void       slot_unlock                          (void);
static void       slot_real_turn_on                    (void);
static void       slot_real_turn_off                   (void);


static void       create_properties                    (GtkWidget            *container,
                                                        PropertyRepository &repository,
                                                        const PropertyList   &properties,
                                                        int                   client,
                                                        int                   level);

static GtkWidget* create_properties_node               (PropertyRepository         &repository,
                                                        PropertyList::const_iterator  begin,
                                                        PropertyList::const_iterator  end,
                                                        int                           client,
                                                        int                           level);

static void       register_frontend_properties         (const PropertyList &properties);
static void       update_frontend_property             (const Property     &property);
static void       register_helper_properties           (int                 client,
                                                        const PropertyList &properties);
static void       update_helper_property               (int                 client,
                                                        const Property     &property);

static void       update_property                      (PropertyRepository &repository,
                                                        const Property       &property);

static void       restore_properties                   (void);

static gboolean   check_exit_timeout_cb                (gpointer data);


/////////////////////////////////////////////////////////////////////////////
// Declaration of internal variables.
/////////////////////////////////////////////////////////////////////////////
#if GDK_MULTIHEAD_SAFE
static GdkScreen         *_current_screen              = 0;
#endif

static GtkWidget         *_input_window                = 0;
static GtkWidget         *_preedit_area                = 0;
static GtkWidget         *_aux_area                    = 0;

static GtkWidget         *_lookup_table_parent         = 0;
static GtkWidget         *_lookup_table_window         = 0;
static GtkWidget         *_lookup_table_up_button      = 0;
static GtkWidget         *_lookup_table_down_button    = 0;
static GtkWidget         *_lookup_table_items [SCIM_LOOKUP_TABLE_MAX_PAGESIZE];

static GtkWidget         *_toolbar_window              = 0;
static GtkWidget         *_factory_button              = 0;
//static GtkWidget         *_factory_menu                = 0;
static GtkWidget         *_help_button                 = 0;
static GtkWidget         *_hide_button                 = 0;
static GtkWidget         *_menu_button                 = 0;
static GtkWidget         *_client_properties_area      = 0;
static GtkWidget         *_frontend_properties_area    = 0;

static GtkWidget         *_help_dialog                 = 0;
static GtkWidget         *_help_scroll                 = 0;
static GtkWidget         *_help_area                   = 0;
static GtkWidget         *_command_menu                = 0;

static GtkWidget         *_vkb_window                  = 0;
static GtkWidget         *_vkb_socket                  = 0;

static GtkTooltips       *_tooltips                    = 0;

static PangoFontDescription *_default_font_desc        = 0;

#if ENABLE_TRAY_ICON
static ScimTrayIcon      *_tray_icon                   = 0;
static GtkWidget         *_tray_icon_factory_button    = 0;
static gulong             _tray_icon_destroy_signal_id = 0;
#endif

static gboolean           _input_window_draging        = FALSE;
static gint               _input_window_drag_x         = 0;
static gint               _input_window_drag_y         = 0;

static gint               _input_window_x              = 0;
static gint               _input_window_y              = 0;
static gint               _input_window_width          = 0;
static gint               _input_window_height         = 0;

static gboolean           _toolbar_window_draging      = FALSE;
static gint               _toolbar_window_drag_x       = 0;
static gint               _toolbar_window_drag_y       = 0;

#if ENABLE_TRAY_ICON
static bool               _show_tray_icon              = true;
#endif

static bool               _toolbar_auto_snap         = bool (SCIM_DEFAULT_VKB_PANEL_TOOLBAR_AUTO_SNAP);
static int                _toolbar_hide_timeout_max  = gint (SCIM_DEFAULT_VKB_PANEL_TOOLBAR_HIDE_TIMEOUT);
static bool               _toolbar_show_factory_icon = bool (SCIM_DEFAULT_VKB_PANEL_TOOLBAR_SHOW_FACTORY_ICON);
static bool               _toolbar_show_factory_name = bool (SCIM_DEFAULT_VKB_PANEL_TOOLBAR_SHOW_FACTORY_NAME);
static bool               _toolbar_show_menu_icon    = bool (SCIM_DEFAULT_VKB_PANEL_TOOLBAR_SHOW_MENU_ICON);
static bool               _toolbar_show_help_icon    = bool (SCIM_DEFAULT_VKB_PANEL_TOOLBAR_SHOW_HELP_ICON);
static bool               _toolbar_show_property_label = bool (SCIM_DEFAULT_VKB_PANEL_TOOLBAR_SHOW_PROPERTY_LABEL);
static bool               _vkb_embedded                = bool (SCIM_DEFAULT_VKB_PANEL_VKB_ENABLED);

static bool               _toolbar_should_hide         = false;
static bool               _toolbar_hidden              = false;
static bool               _factory_menu_activated      = false;
static bool               _command_menu_activated      = false;
static bool               _property_menu_activated     = false;

static int                _spot_location_x             = -1;
static int                _spot_location_y             = -1;

static int                _toolbar_window_x            = -1;
static int                _toolbar_window_y            = -1;
static int                _toolbar_hide_timeout_count  = 0;
static guint              _toolbar_hide_timeout        = 0;

static bool               _ui_initialized              = false;

static int                _lookup_table_index [SCIM_LOOKUP_TABLE_MAX_PAGESIZE+1];

static GdkColor           _normal_fg;
static GdkColor           _normal_bg;
static GdkColor           _normal_text;
static GdkColor           _active_bg;
static GdkColor           _active_text;

static ConfigModule      *_config_module               = 0;
static ConfigPointer      _config;

static guint              _check_exit_timeout          = 0;

static bool               _should_exit                 = false;

static bool               _panel_is_on                 = false;

static bool               _vkb_is_alone                = false;

static GThread           *_panel_agent_thread          = 0;

static PanelAgent        *_panel_agent                 = 0;

static std::vector<String> _factory_menu_uuids;

static std::list<String>  _recent_factory_uuids;

static struct timeval     _last_menu_deactivate_time = {0, 0};

//dbus related methods

gboolean panel_vkb_turn_on_panel(PanelVkbDbusObj * dbusobj, GError **error)
{
    printf("in////////////////////////////// panel_vkb_turn_on_panel\n");
    ComposeKeyFactory factory;
    PanelFactoryInfo info = PanelFactoryInfo (factory.get_uuid(),
                                utf8_wcstombs(factory.get_name()),
                                String ("C"),
                                factory.get_icon_file());
    _panel_agent->change_factory (factory.get_uuid());
    slot_update_factory_info(info);
    slot_hide_lookup_table();
    slot_real_turn_on();
    gtk_widget_hide(_toolbar_window);
    return TRUE;
}
/* this function is the original
gboolean panel_vkb_turn_off_panel(PanelVkbDbusObj * dbusobj, GError **error)
{
    slot_real_turn_off();
    _panel_agent->change_factory ("");
    return TRUE;
}
*/
// I modify the up funtion by comment line 475,and it works well
gboolean panel_vkb_turn_off_panel(PanelVkbDbusObj * dbusobj, GError **error)
{
    //printf("''''''''''''in panel_vkb_turn_off_panel\n");
    slot_real_turn_off();
    return TRUE;
}

gboolean panel_vkb_toggle_vkb_alone(PanelVkbDbusObj * dbusobj, GError **error)
{
    //printf("in panel_vkb_toggle_vkb_alone\n");
	if(_vkb_embedded)
	{
            gtk_window_get_size (GTK_WINDOW (_input_window), &_input_window_width, &_input_window_height);
		if(!_vkb_is_alone)
		{
		    //no can see 
		    printf("thisis in panel_vkb_toggle_vkb_alone if\n");
			ComposeKeyFactory factory;
			PanelFactoryInfo info = PanelFactoryInfo (factory.get_uuid(),
					utf8_wcstombs(factory.get_name()),
					String ("C"),
					factory.get_icon_file());

			gtk_widget_hide(_lookup_table_parent);
			gtk_window_move(GTK_WINDOW(_input_window), 0, 566);
			_panel_agent->change_factory (factory.get_uuid());
			_vkb_is_alone = true;
			slot_real_turn_on();
		    	//printf("inccccccccccccc22222222222222  panel_vkb_toogle_vkb_alone \n");
			//std::cerr<<factory.get_uuid();
		}
		else
		{// can see
		    	printf("\nin22222222222222  panel_vkb_toogle_vkb_alone \n");
			gtk_window_move(GTK_WINDOW(_input_window), 0, 533);
			gtk_widget_show(_aux_area);
			gtk_widget_show(_lookup_table_window);
			gtk_widget_show(_toolbar_window);
			gtk_widget_show(_lookup_table_parent);
			_vkb_is_alone = false;
			slot_real_turn_on();
     			_panel_agent->request_factory_menu ();
			//std::cerr<<_factory_menu_uuids[0];
        		_panel_agent->change_factory (_factory_menu_uuids [0]);
        		//_panel_agent->change_factory ("05235cfc-43ce-490c-b1b1-c5a2185276ae");
		}
	}
    return TRUE;
}

// Record vkb's pid for kill when exit.
int VKB_PID = 0;

/* if _vkb_dock_panel is true, then we will try to reserve part of screen area for vkb 
 * by setting _NET_WM_STRUT_PARTIAL property, so that the other window will not
 * be overlapped
 */
static bool               _vkb_dock_panel              = bool (SCIM_DEFAULT_VKB_DOCKPANEL);
static gint               _panel_strut_size            = 0;

/* if _vkb_panel_extend is true, then the panel will extend to the full width of workarea.
 * no matter what's the value of _vkb_window_width  */
static bool               _vkb_panel_extend            = bool (SCIM_DEFAULT_VKB_PANEL_EXTEND);

static String             _vkb_program                 = String (SCIM_DEFAULT_VKB_PROGRAM);
static String             _vkb_parameters              = String (SCIM_DEFAULT_VKB_PARAMETERS);
static gint               _vkb_window_width            = gint (SCIM_DEFAULT_VKB_WINDOW_WIDTH);
static gint               _vkb_window_height           = gint (SCIM_DEFAULT_VKB_WINDOW_HEIGHT);

static gint               _workarea_x                  = 0;
static gint               _workarea_y                  = 0;
static gint               _workarea_width              = 800;
static gint               _workarea_height             = 600;

static gint               _lookup_table_width          = -1;

// client repository
static PropertyRepository            _frontend_property_repository;
static HelperPropertyRepository      _helper_property_repository;
static std::vector<HelperInfo>       _helper_list;

G_LOCK_DEFINE_STATIC     (_global_resource_lock);
G_LOCK_DEFINE_STATIC     (_panel_agent_lock);


/////////////////////////////////////////////////////////////////////////////
// Implementation of internal functions.
/////////////////////////////////////////////////////////////////////////////
static void
ui_config_reload_callback (const ConfigPointer &config)
{
    _config = config;
    ui_initialize ();
    restore_properties ();
}

static void
ui_load_config (void)
{
    String str;

    // Read configurations.
    if (_default_font_desc) {
        pango_font_description_free (_default_font_desc);
        _default_font_desc = 0;
    }

    if (!_config.null ()) {
        str = _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_FONT),
                              String (SCIM_DEFAULT_VKB_PANEL_FONT));

        if (str != String ("default"))
            _default_font_desc = pango_font_description_from_string (str.c_str ());

        str = _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_PANEL_NORMAL_FG_COLOR),
                             String (SCIM_DEFAULT_VKB_PANEL_NORMAL_FG_COLOR));
        gdk_color_parse (str.c_str (), &_normal_fg);

        str = _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_PANEL_NORMAL_BG_COLOR),
                             String (SCIM_DEFAULT_VKB_PANEL_NORMAL_BG_COLOR));
        gdk_color_parse (str.c_str (), &_normal_bg);

        str = _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_PANEL_NORMAL_TEXT_COLOR),
                             String (SCIM_DEFAULT_VKB_PANEL_NORMAL_TEXT_COLOR));
        gdk_color_parse (str.c_str (), &_normal_text);

        str = _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_PANEL_ACTIVE_BG_COLOR),
                             String (SCIM_DEFAULT_VKB_PANEL_ACTIVE_BG_COLOR));
        gdk_color_parse (str.c_str (), &_active_bg);

        str = _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_PANEL_ACTIVE_TEXT_COLOR),
                             String (SCIM_DEFAULT_VKB_PANEL_ACTIVE_TEXT_COLOR));
        gdk_color_parse (str.c_str (), &_active_text);

        _toolbar_window_x = _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_TOOLBAR_POS_X),
                                           _toolbar_window_x);

        _toolbar_window_y = _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_TOOLBAR_POS_Y),
                                           _toolbar_window_y);

        _toolbar_auto_snap =
            _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_TOOLBAR_AUTO_SNAP),
                           _toolbar_auto_snap);

        _toolbar_show_factory_icon =
            _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_TOOLBAR_SHOW_FACTORY_ICON),
                           _toolbar_show_factory_icon);

        _toolbar_show_factory_name =
            _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_TOOLBAR_SHOW_FACTORY_NAME),
                           _toolbar_show_factory_name);

        _toolbar_show_help_icon =
            _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_TOOLBAR_SHOW_HELP_ICON),
                           _toolbar_show_help_icon);

        _toolbar_show_menu_icon =
            _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_TOOLBAR_SHOW_MENU_ICON),
                           _toolbar_show_menu_icon);

        _toolbar_show_property_label =
            _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_TOOLBAR_SHOW_PROPERTY_LABEL),
                           _toolbar_show_property_label);

        _toolbar_hide_timeout_max =
            _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_TOOLBAR_HIDE_TIMEOUT),
                           _toolbar_hide_timeout_max);

        _vkb_dock_panel = 
            _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_DOCK_PANEL),
                           _vkb_dock_panel);

        _vkb_panel_extend = 
            _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_PANEL_EXTEND),
                           _vkb_panel_extend);

        _vkb_program = 
            _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_VKB_PROGRAM),
                           _vkb_program);

        _vkb_parameters = 
            _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_VKB_PARAMETERS),
                           _vkb_parameters);

        _vkb_window_width = 
            _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_VKB_WIDTH),
                           _vkb_window_width);

        _vkb_window_height = 
            _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_VKB_HEIGHT),
                           _vkb_window_height);

        _vkb_embedded =
            _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_ENABLE_VKB),
                           _vkb_embedded);
#if ENABLE_TRAY_ICON
        _show_tray_icon =
            _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_SHOW_TRAY_ICON),
                           _show_tray_icon);
#endif
    }
}

#ifdef GDK_WINDOWING_X11
static GdkFilterReturn
ui_event_filter (GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
{
    g_return_val_if_fail (gdk_xevent, GDK_FILTER_CONTINUE);

    XEvent *xev = (XEvent*)gdk_xevent;

    if (xev->type == PropertyNotify) {
        if (xev->xproperty.atom == gdk_x11_get_xatom_by_name ("_NET_WORKAREA") ||
            xev->xproperty.atom == gdk_x11_get_xatom_by_name ("_NET_CURRENT_DESKTOP")) {
			ui_settle_toolbar_window ();
        }
    }

    return GDK_FILTER_CONTINUE;
}
#endif

static void
ui_initialize (void)
{
    SCIM_DEBUG_MAIN (1) << "Initialize UI...\n";


    GtkWidget *input_window_vbox;

    ui_load_config ();

    if (_lookup_table_window) gtk_widget_destroy (_lookup_table_window);
    if (_vkb_window) gtk_widget_destroy (_vkb_window);
    if (_input_window) gtk_widget_destroy (_input_window);
    if (_toolbar_window) gtk_widget_destroy (_toolbar_window);
    if (_help_dialog) gtk_widget_destroy (_help_dialog);
    if (_tooltips) gtk_object_destroy (GTK_OBJECT (_tooltips));
	if (_lookup_table_parent) gtk_object_destroy(GTK_OBJECT(_lookup_table_parent));

#if ENABLE_TRAY_ICON
    if (_tray_icon) {
        g_signal_handler_disconnect (G_OBJECT (_tray_icon),
                                     _tray_icon_destroy_signal_id);
        gtk_widget_destroy (GTK_WIDGET (_tray_icon));
    }
    _tray_icon = 0;
#endif

    _lookup_table_window = 0;
	_lookup_table_parent = 0;
    _input_window = 0;
    _vkb_window = 0;
    _toolbar_window = 0;
    _help_dialog = 0;
    _tooltips = 0;

    _lookup_table_width = -1;

#if GDK_MULTIHEAD_SAFE
    // Initialize the Display and Screen.
    _current_screen  = gdk_screen_get_default ();
#endif


if(_vkb_embedded)
{
    // Create main UI window
    {
        GtkWidget *vbox;
        GtkWidget *hbox;
        GtkWidget *separator;

        _input_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
        gtk_window_set_decorated (GTK_WINDOW (_input_window), FALSE);
        gtk_window_set_accept_focus (GTK_WINDOW (_input_window), FALSE);
        gtk_window_set_keep_above (GTK_WINDOW (_input_window), TRUE);
        gtk_window_set_skip_taskbar_hint (GTK_WINDOW (_input_window), TRUE);
        gtk_window_set_skip_pager_hint (GTK_WINDOW (_input_window), TRUE);
        gtk_window_set_resizable (GTK_WINDOW (_input_window), FALSE);

        if (_vkb_dock_panel) {
	    printf("vvvvvvvvvvvvvvvv\n");
            gtk_window_set_type_hint (GTK_WINDOW (_input_window), GDK_WINDOW_TYPE_HINT_DOCK);
        } else {
            gtk_widget_add_events (_input_window,GDK_BUTTON_PRESS_MASK);
            gtk_widget_add_events (_input_window,GDK_BUTTON_RELEASE_MASK);
            gtk_widget_add_events (_input_window,GDK_POINTER_MOTION_MASK);
            g_signal_connect (G_OBJECT (_input_window), "button-press-event",
                              G_CALLBACK (ui_input_window_click_cb),
                              GINT_TO_POINTER (0));
            g_signal_connect (G_OBJECT (_input_window), "button-release-event",
                              G_CALLBACK (ui_input_window_click_cb),
                              GINT_TO_POINTER (1));
        }

        gtk_widget_modify_bg (_input_window, GTK_STATE_NORMAL, &_normal_bg);
        //gtk_window_set_policy (GTK_WINDOW (_input_window), TRUE, TRUE, FALSE);

        hbox = gtk_hbox_new (FALSE, 0);
        gtk_container_add (GTK_CONTAINER (_input_window), hbox);

        vbox = gtk_vbox_new (FALSE, 0);
        gtk_box_pack_start (GTK_BOX (hbox), vbox, TRUE, TRUE, 0);
        input_window_vbox = vbox;

        separator = gtk_hseparator_new ();
        gtk_widget_modify_bg(separator, GTK_STATE_NORMAL, &_normal_fg);
        gtk_box_pack_start (GTK_BOX (vbox), separator, FALSE, FALSE, 0);
    }

    //Create lookup table window
    {
        //GtkWidget *_lookup_table_parent;
        GtkWidget *hbox;
        GtkWidget *vbox;
        GtkWidget *image;
        GtkWidget *separator;

        vbox = gtk_vbox_new (FALSE, 0);
        gtk_box_pack_start (GTK_BOX (input_window_vbox), vbox, TRUE, TRUE, 0);
        
        gtk_widget_show_all (vbox);

        _lookup_table_parent = gtk_hbox_new (FALSE, 0);
        gtk_widget_set_size_request (_lookup_table_parent, -1, LOOKUP_TABLE_MIN_HEIGHT);
        gtk_box_pack_start (GTK_BOX (vbox), _lookup_table_parent, TRUE, TRUE, 0);

#if 1
        //Create aux area
        _aux_area = scim_string_view_new ();
        if (_default_font_desc)
            gtk_widget_modify_font (_aux_area, _default_font_desc);
        gtk_widget_modify_base (_aux_area, GTK_STATE_NORMAL, &_normal_bg);
        gtk_widget_modify_base (_aux_area, GTK_STATE_ACTIVE, &_active_bg);
        gtk_widget_modify_text (_aux_area, GTK_STATE_NORMAL, &_normal_text);
        gtk_widget_modify_text (_aux_area, GTK_STATE_ACTIVE, &_active_text);
        scim_string_view_set_width_chars (SCIM_STRING_VIEW (_aux_area), 24);
        scim_string_view_set_draw_cursor (SCIM_STRING_VIEW (_aux_area), FALSE);
        scim_string_view_set_forward_event (SCIM_STRING_VIEW (_aux_area), TRUE);
        scim_string_view_set_auto_resize (SCIM_STRING_VIEW (_aux_area), TRUE);
        scim_string_view_set_has_frame (SCIM_STRING_VIEW (_aux_area), FALSE);
        gtk_box_pack_start (GTK_BOX (_lookup_table_parent), _aux_area, FALSE, FALSE, 0);

        separator = gtk_vseparator_new ();
        gtk_widget_modify_bg(separator, GTK_STATE_NORMAL, &_normal_bg);
        gtk_box_pack_start (GTK_BOX (_lookup_table_parent), separator, FALSE, FALSE, 0);
#endif

        //Create toolbar window, We pack it in _lookup_table_parent
        {
            GtkWidget *hbox;
            GtkWidget *image;

            hbox = gtk_hbox_new (FALSE, 0);
            _toolbar_window = hbox;

            //New factory button
            if (_toolbar_show_factory_icon || _toolbar_show_factory_name) {
                _factory_button = gtk_button_new ();

                gtk_widget_modify_bg(_factory_button, GTK_STATE_NORMAL, &_normal_bg);
                gtk_widget_modify_bg(_factory_button, GTK_STATE_PRELIGHT, &_normal_bg);
                gtk_widget_modify_bg(_factory_button, GTK_STATE_ACTIVE, &_normal_bg);

                gtk_button_set_relief (GTK_BUTTON (_factory_button), GTK_RELIEF_NONE);
                gtk_box_pack_start (GTK_BOX (hbox), _factory_button, TRUE, TRUE, 0);
                //g_signal_connect (G_OBJECT (_factory_button), "clicked",
                  //                G_CALLBACK (ui_factory_button_click_cb),
                    //              0);
            }

            // Put all properties here
            //_client_properties_area = gtk_hbox_new (FALSE, 0);
            //gtk_box_pack_start (GTK_BOX (hbox), _client_properties_area, TRUE, TRUE, 0);
            //gtk_widget_show (_client_properties_area);

            //New menu button
            //we always need menu button for VKB embedded mode.
        /*    {
                image = ui_create_menu_icon ();
                _menu_button = gtk_button_new ();

                gtk_widget_modify_bg(_menu_button, GTK_STATE_NORMAL, &_normal_bg);
                gtk_widget_modify_bg(_menu_button, GTK_STATE_PRELIGHT, &_normal_bg);
                gtk_widget_modify_bg(_menu_button, GTK_STATE_ACTIVE, &_normal_bg);

                gtk_button_set_relief (GTK_BUTTON (_menu_button), GTK_RELIEF_NONE);
                gtk_container_add (GTK_CONTAINER (_menu_button), image);
                gtk_box_pack_start (GTK_BOX (hbox), _menu_button, TRUE, TRUE, 0);
                g_signal_connect (G_OBJECT (_menu_button), "clicked",
                                  G_CALLBACK (ui_menu_button_click_cb),
                                  image);
            }
*/
            //New help button
            //if (_toolbar_show_help_icon) {
            if (0) {
                image = ui_create_help_icon ();
                _help_button = gtk_button_new ();
                gtk_widget_modify_bg(_help_button, GTK_STATE_NORMAL, &_normal_bg);
                gtk_widget_modify_bg(_help_button, GTK_STATE_PRELIGHT, &_normal_bg);
                gtk_widget_modify_bg(_help_button, GTK_STATE_ACTIVE, &_normal_bg);

                gtk_button_set_relief (GTK_BUTTON (_help_button), GTK_RELIEF_NONE);
                gtk_container_add (GTK_CONTAINER (_help_button), image);
                gtk_box_pack_start (GTK_BOX (hbox), _help_button, TRUE, TRUE, 0);
                g_signal_connect (G_OBJECT (_help_button), "clicked",
                                  G_CALLBACK (ui_help_button_click_cb),
                                  image);
            }

            gtk_box_pack_end (GTK_BOX (_lookup_table_parent), _toolbar_window, FALSE, FALSE, 0);
            gtk_widget_show_all (_toolbar_window);
            gtk_widget_hide (_toolbar_window);
        }

        // Create Look up table
        hbox = gtk_hbox_new (FALSE, 0);
        gtk_box_pack_start (GTK_BOX (_lookup_table_parent), hbox, TRUE, TRUE, 0);
        _lookup_table_window = hbox;

        _lookup_table_items [0] = scim_string_view_new ();
        if (_default_font_desc)
            gtk_widget_modify_font (_lookup_table_items [0], _default_font_desc);
        gtk_widget_modify_base (_lookup_table_items [0], GTK_STATE_NORMAL, &_normal_bg);
        gtk_widget_modify_base (_lookup_table_items [0], GTK_STATE_ACTIVE, &_active_bg);
        gtk_widget_modify_text (_lookup_table_items [0], GTK_STATE_NORMAL, &_normal_text);
        gtk_widget_modify_text (_lookup_table_items [0], GTK_STATE_ACTIVE, &_active_text);
        scim_string_view_set_forward_event (SCIM_STRING_VIEW (_lookup_table_items [0]), TRUE);
        scim_string_view_set_auto_resize (SCIM_STRING_VIEW (_lookup_table_items [0]), TRUE);
        scim_string_view_set_has_frame (SCIM_STRING_VIEW (_lookup_table_items [0]), FALSE);
        scim_string_view_set_draw_cursor (SCIM_STRING_VIEW (_lookup_table_items [0]), FALSE);
        scim_string_view_set_auto_move_cursor (SCIM_STRING_VIEW (_lookup_table_items [0]), FALSE);
        g_signal_connect (G_OBJECT (_lookup_table_items [0]), "move_cursor",
                        G_CALLBACK (ui_lookup_table_horizontal_click_cb),
                        0);
        gtk_box_pack_start (GTK_BOX (_lookup_table_window), _lookup_table_items [0], TRUE, TRUE, 0);


        //New right button
        image = ui_create_right_icon ();
        _lookup_table_down_button = gtk_button_new ();
        gtk_container_add (GTK_CONTAINER (_lookup_table_down_button), image);

        gtk_box_pack_end (GTK_BOX (_lookup_table_window), _lookup_table_down_button, FALSE, FALSE, 0);
        g_signal_connect (G_OBJECT (_lookup_table_down_button), "clicked",
                            G_CALLBACK (ui_lookup_table_down_button_click_cb),
                            image);

        //New left button
        image = ui_create_left_icon ();
        _lookup_table_up_button = gtk_button_new ();
        gtk_container_add (GTK_CONTAINER (_lookup_table_up_button), image);

        gtk_box_pack_end (GTK_BOX (_lookup_table_window), _lookup_table_up_button, FALSE, FALSE, 0);
        g_signal_connect (G_OBJECT (_lookup_table_up_button), "clicked",
                            G_CALLBACK (ui_lookup_table_up_button_click_cb),
                            image);

        gtk_button_set_relief (GTK_BUTTON (_lookup_table_up_button), GTK_RELIEF_NONE);
        gtk_widget_modify_bg (_lookup_table_up_button, GTK_STATE_ACTIVE, &_normal_bg);
        gtk_widget_modify_bg (_lookup_table_up_button, GTK_STATE_INSENSITIVE, &_normal_bg);
        gtk_widget_modify_bg (_lookup_table_up_button, GTK_STATE_PRELIGHT, &_normal_bg);

        gtk_button_set_relief (GTK_BUTTON (_lookup_table_down_button), GTK_RELIEF_NONE);
        gtk_widget_modify_bg (_lookup_table_down_button, GTK_STATE_ACTIVE, &_normal_bg);
        gtk_widget_modify_bg (_lookup_table_down_button, GTK_STATE_INSENSITIVE, &_normal_bg);
        gtk_widget_modify_bg (_lookup_table_down_button, GTK_STATE_PRELIGHT, &_normal_bg);

        separator = gtk_vseparator_new ();
        gtk_widget_modify_bg(separator, GTK_STATE_NORMAL, &_normal_bg);
        gtk_box_pack_end (GTK_BOX (_lookup_table_window), separator, FALSE, FALSE, 0);

    }

    // figure out the free area size of the desktop
    ui_get_workarea (_workarea_x, _workarea_y, _workarea_width, _workarea_height);

    //Create VKB window
	GtkWidget *separator;
	GtkWidget *vkb_socket_box;
	unsigned long     kb_xid = 0;

	kb_xid = launch_keyboard (_vkb_program.c_str(), _vkb_parameters.c_str(), &VKB_PID);

	if (kb_xid) {
		_vkb_window  = gtk_vbox_new (FALSE, 0);

		if (_vkb_panel_extend) {
			gtk_widget_set_size_request (_vkb_window, _workarea_width, _vkb_window_height);
            gtk_widget_set_size_request (_lookup_table_parent, _workarea_width, LOOKUP_TABLE_MIN_HEIGHT);
            _lookup_table_width = _workarea_width * 3 / 4;
        } else {
			gtk_widget_set_size_request (_vkb_window, _vkb_window_width, _vkb_window_height);
            gtk_widget_set_size_request (_lookup_table_parent, _vkb_window_width, LOOKUP_TABLE_MIN_HEIGHT);
            _lookup_table_width = _vkb_window_width * 3 / 4;
        }        

		gtk_box_pack_start (GTK_BOX (input_window_vbox), _vkb_window, TRUE, TRUE, 0);

		separator = gtk_hseparator_new ();
		gtk_widget_modify_bg(separator, GTK_STATE_NORMAL, &_normal_bg);
		gtk_box_pack_start (GTK_BOX (_vkb_window), separator, FALSE, FALSE, 0);

		vkb_socket_box = gtk_event_box_new ();
		gtk_widget_modify_bg(vkb_socket_box, GTK_STATE_NORMAL, &_normal_bg);

		gtk_widget_show (vkb_socket_box);

		_vkb_socket = gtk_socket_new();
		gtk_container_add (GTK_CONTAINER (vkb_socket_box), _vkb_socket);
		gtk_box_pack_start (GTK_BOX (_vkb_window), vkb_socket_box, TRUE, TRUE, 0);

		gtk_socket_add_id (GTK_SOCKET(_vkb_socket), kb_xid);
	} else {
		// could not launch VKB, so set _vkb_embedded to FALSE
		_vkb_embedded = FALSE;
	}

    if (_lookup_table_width > 0)
        scim_string_view_set_max_width (SCIM_STRING_VIEW (_lookup_table_items [0]), _lookup_table_width);

    // we call show all for _input_window to get the right window size and then hide part of the children.
    gtk_widget_show_all (_input_window);
    gtk_widget_hide (_input_window);


    if (_vkb_dock_panel) {
        ui_settle_input_window (false, false);
    }

    if (_vkb_embedded)
        gtk_widget_hide (_vkb_window);

}
else //if VKB is not enabled
{
  // Create input window
    {
        GtkWidget *vbox;
        GtkWidget *hbox;
        GtkWidget *frame;

        _input_window = gtk_window_new (GTK_WINDOW_POPUP);
        gtk_widget_modify_bg (_input_window, GTK_STATE_NORMAL, &_normal_bg);
        gtk_window_set_policy (GTK_WINDOW (_input_window), TRUE, TRUE, FALSE);
        gtk_window_set_resizable (GTK_WINDOW (_input_window), FALSE);
        gtk_window_set_skip_taskbar_hint (GTK_WINDOW (_input_window), TRUE);
        gtk_window_set_skip_pager_hint (GTK_WINDOW (_input_window), TRUE);
        gtk_widget_add_events (_input_window,GDK_BUTTON_PRESS_MASK);
        gtk_widget_add_events (_input_window,GDK_BUTTON_RELEASE_MASK);
        gtk_widget_add_events (_input_window,GDK_POINTER_MOTION_MASK);
        g_signal_connect (G_OBJECT (_input_window), "button-press-event",
                          G_CALLBACK (ui_input_window_click_cb),
                          GINT_TO_POINTER (0));
        g_signal_connect (G_OBJECT (_input_window), "button-release-event",
                          G_CALLBACK (ui_input_window_click_cb),
                          GINT_TO_POINTER (1));

        frame = gtk_frame_new (0);
        gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_ETCHED_OUT);
        gtk_container_add (GTK_CONTAINER (_input_window), frame);

        hbox = gtk_hbox_new (FALSE, 0);
        gtk_container_add (GTK_CONTAINER (frame), hbox);

        vbox = gtk_vbox_new (FALSE, 0);
        gtk_box_pack_start (GTK_BOX (hbox), vbox, TRUE, TRUE, 0);
        input_window_vbox = vbox;

        //Create preedit area
        _preedit_area = scim_string_view_new ();
        if (_default_font_desc)
            gtk_widget_modify_font (_preedit_area, _default_font_desc);
        gtk_widget_modify_base (_preedit_area, GTK_STATE_NORMAL, &_normal_bg);
        gtk_widget_modify_base (_preedit_area, GTK_STATE_ACTIVE, &_active_bg);
        gtk_widget_modify_text (_preedit_area, GTK_STATE_NORMAL, &_normal_text);
        gtk_widget_modify_text (_preedit_area, GTK_STATE_ACTIVE, &_active_text);
        scim_string_view_set_width_chars (SCIM_STRING_VIEW (_preedit_area), 24);
        scim_string_view_set_forward_event (SCIM_STRING_VIEW (_preedit_area), TRUE);
        scim_string_view_set_auto_resize (SCIM_STRING_VIEW (_preedit_area), TRUE);
        scim_string_view_set_has_frame (SCIM_STRING_VIEW (_preedit_area), FALSE);
        g_signal_connect (G_OBJECT (_preedit_area), "move_cursor",
                          G_CALLBACK (ui_preedit_area_move_cursor_cb),
                          0);
        gtk_box_pack_start (GTK_BOX (vbox), _preedit_area, TRUE, TRUE, 0);

        //Create aux area
        _aux_area = scim_string_view_new ();
        if (_default_font_desc)
            gtk_widget_modify_font (_aux_area, _default_font_desc);
        gtk_widget_modify_base (_aux_area, GTK_STATE_NORMAL, &_normal_bg);
        gtk_widget_modify_base (_aux_area, GTK_STATE_ACTIVE, &_active_bg);
        gtk_widget_modify_text (_aux_area, GTK_STATE_NORMAL, &_normal_text);
        gtk_widget_modify_text (_aux_area, GTK_STATE_ACTIVE, &_active_text);
        scim_string_view_set_width_chars (SCIM_STRING_VIEW (_aux_area), 24);
        scim_string_view_set_draw_cursor (SCIM_STRING_VIEW (_aux_area), FALSE);
        scim_string_view_set_forward_event (SCIM_STRING_VIEW (_aux_area), TRUE);
        scim_string_view_set_auto_resize (SCIM_STRING_VIEW (_aux_area), TRUE);
        scim_string_view_set_has_frame (SCIM_STRING_VIEW (_aux_area), FALSE);
        gtk_box_pack_start (GTK_BOX (vbox), _aux_area, TRUE, TRUE, 0);

        gtk_window_move (GTK_WINDOW (_input_window), ui_screen_width (), ui_screen_height ());

    }

    //Create lookup table window
    {
        GtkWidget *hbox;
        GtkWidget *image;
        GtkWidget *separator;

        //the lookup table is defaultly emdedded into input panel
            _lookup_table_window = gtk_vbox_new (FALSE, 0);
            gtk_box_pack_start (GTK_BOX (input_window_vbox), _lookup_table_window, TRUE, TRUE, 0);
            _lookup_table_parent = _lookup_table_window;
            separator = gtk_hseparator_new ();
            gtk_box_pack_start (GTK_BOX (_lookup_table_parent), separator, FALSE, FALSE, 0);

        //lookup table
       {
            hbox = gtk_hbox_new (FALSE, 0);
            gtk_container_add (GTK_CONTAINER (_lookup_table_parent), hbox);

            _lookup_table_items [0] = scim_string_view_new ();
            if (_default_font_desc)
                gtk_widget_modify_font (_lookup_table_items [0], _default_font_desc);
            gtk_widget_modify_base (_lookup_table_items [0], GTK_STATE_NORMAL, &_normal_bg);
            gtk_widget_modify_base (_lookup_table_items [0], GTK_STATE_ACTIVE, &_active_bg);
            gtk_widget_modify_text (_lookup_table_items [0], GTK_STATE_NORMAL, &_normal_text);
            gtk_widget_modify_text (_lookup_table_items [0], GTK_STATE_ACTIVE, &_active_text);
            scim_string_view_set_forward_event (SCIM_STRING_VIEW (_lookup_table_items [0]), TRUE);
            scim_string_view_set_auto_resize (SCIM_STRING_VIEW (_lookup_table_items [0]), TRUE);
            scim_string_view_set_has_frame (SCIM_STRING_VIEW (_lookup_table_items [0]), FALSE);
            scim_string_view_set_draw_cursor (SCIM_STRING_VIEW (_lookup_table_items [0]), FALSE);
            scim_string_view_set_auto_move_cursor (SCIM_STRING_VIEW (_lookup_table_items [0]), FALSE);
            g_signal_connect (G_OBJECT (_lookup_table_items [0]), "move_cursor",
                            G_CALLBACK (ui_lookup_table_horizontal_click_cb),
                            0);
            gtk_box_pack_start (GTK_BOX (hbox), _lookup_table_items [0], TRUE, TRUE, 0);

            separator = gtk_vseparator_new ();
            gtk_box_pack_start (GTK_BOX (hbox), separator, FALSE, FALSE, 0);

            //New left button
            image = ui_create_left_icon ();
            _lookup_table_up_button = gtk_button_new ();
            gtk_container_add (GTK_CONTAINER (_lookup_table_up_button), image);

            gtk_box_pack_start (GTK_BOX (hbox), _lookup_table_up_button, FALSE, FALSE, 0);
            g_signal_connect (G_OBJECT (_lookup_table_up_button), "clicked",
                                G_CALLBACK (ui_lookup_table_up_button_click_cb),
                                image);

            //New right button
            image = ui_create_right_icon ();
            _lookup_table_down_button = gtk_button_new ();
            gtk_container_add (GTK_CONTAINER (_lookup_table_down_button), image);

            gtk_box_pack_start (GTK_BOX (hbox), _lookup_table_down_button, FALSE, FALSE, 0);

            g_signal_connect (G_OBJECT (_lookup_table_down_button), "clicked",
                                G_CALLBACK (ui_lookup_table_down_button_click_cb),
                                image);
        }

        gtk_button_set_relief (GTK_BUTTON (_lookup_table_up_button), GTK_RELIEF_NONE);
        gtk_widget_modify_bg (_lookup_table_up_button, GTK_STATE_ACTIVE, &_normal_bg);
        gtk_widget_modify_bg (_lookup_table_up_button, GTK_STATE_INSENSITIVE, &_normal_bg);
        gtk_widget_modify_bg (_lookup_table_up_button, GTK_STATE_PRELIGHT, &_normal_bg);

        gtk_button_set_relief (GTK_BUTTON (_lookup_table_down_button), GTK_RELIEF_NONE);
        gtk_widget_modify_bg (_lookup_table_down_button, GTK_STATE_ACTIVE, &_normal_bg);
        gtk_widget_modify_bg (_lookup_table_down_button, GTK_STATE_INSENSITIVE, &_normal_bg);
        gtk_widget_modify_bg (_lookup_table_down_button, GTK_STATE_PRELIGHT, &_normal_bg);

    }
        gtk_widget_show_all (_input_window);
        gtk_widget_hide (_input_window);

    //Create toolbar window
    {
        GtkWidget *hbox;
        GtkWidget *frame;
        GtkWidget *image;

        _toolbar_window = gtk_window_new (GTK_WINDOW_POPUP);
        gtk_window_set_policy (GTK_WINDOW (_toolbar_window), TRUE, TRUE, FALSE);
        gtk_window_set_resizable (GTK_WINDOW (_toolbar_window), FALSE);
        gtk_widget_modify_bg(_toolbar_window, GTK_STATE_NORMAL, &_normal_bg);
        gtk_widget_add_events (_toolbar_window,GDK_BUTTON_PRESS_MASK);
        gtk_widget_add_events (_toolbar_window,GDK_BUTTON_RELEASE_MASK);
        gtk_widget_add_events (_toolbar_window,GDK_POINTER_MOTION_MASK);
        g_signal_connect (G_OBJECT (_toolbar_window), "button-press-event",
                          G_CALLBACK (ui_toolbar_window_click_cb),
                          GINT_TO_POINTER (0));
        g_signal_connect (G_OBJECT (_toolbar_window), "button-release-event",
                          G_CALLBACK (ui_toolbar_window_click_cb),
                          GINT_TO_POINTER (1));

        frame = gtk_frame_new (0);
        gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_ETCHED_OUT);
        gtk_container_add (GTK_CONTAINER (_toolbar_window), frame);

        hbox = gtk_hbox_new (FALSE, 0);
        gtk_container_add (GTK_CONTAINER (frame), hbox);

        //New trademark pixmap
        image = ui_create_trademark_icon ();
        gtk_box_pack_start (GTK_BOX (hbox), image, FALSE, FALSE, 0);


        //New factory button
        if (_toolbar_show_factory_icon || _toolbar_show_factory_name) {
            _factory_button = gtk_button_new ();
            gtk_widget_modify_bg(_factory_button, GTK_STATE_NORMAL, &_normal_bg);
            gtk_widget_modify_bg(_factory_button, GTK_STATE_PRELIGHT, &_normal_bg);
            gtk_widget_modify_bg(_factory_button, GTK_STATE_ACTIVE, &_normal_bg);

            gtk_button_set_relief (GTK_BUTTON (_factory_button), GTK_RELIEF_NONE);
            gtk_box_pack_start (GTK_BOX (hbox), _factory_button, TRUE, TRUE, 0);
            g_signal_connect (G_OBJECT (_factory_button), "button-release-event",
                              G_CALLBACK (ui_factory_button_released_cb),
                              0);
        }

        // Put all properties here
        _client_properties_area = gtk_hbox_new (FALSE, 0);
        gtk_box_pack_start (GTK_BOX (hbox), _client_properties_area, TRUE, TRUE, 0);
        gtk_widget_show (_client_properties_area);

        //New menu button
        if (_toolbar_show_menu_icon) {
            image = ui_create_menu_icon ();
            _menu_button = gtk_button_new ();
            gtk_widget_modify_bg(_menu_button, GTK_STATE_NORMAL, &_normal_bg);
            gtk_widget_modify_bg(_menu_button, GTK_STATE_PRELIGHT, &_normal_bg);
            gtk_widget_modify_bg(_menu_button, GTK_STATE_ACTIVE, &_normal_bg);

            gtk_button_set_relief (GTK_BUTTON (_menu_button), GTK_RELIEF_NONE);
            gtk_container_add (GTK_CONTAINER (_menu_button), image);
            gtk_box_pack_start (GTK_BOX (hbox), _menu_button, TRUE, TRUE, 0);
            g_signal_connect (G_OBJECT (_menu_button), "clicked",
                              G_CALLBACK (ui_menu_button_click_cb),
                              image);
        }

        //New help button
        if (_toolbar_show_help_icon) {
    		image = ui_create_help_icon ();
    		_help_button = gtk_button_new ();
            gtk_widget_modify_bg(_help_button, GTK_STATE_NORMAL, &_normal_bg);
            gtk_widget_modify_bg(_help_button, GTK_STATE_PRELIGHT, &_normal_bg);
            gtk_widget_modify_bg(_help_button, GTK_STATE_ACTIVE, &_normal_bg);

    		gtk_button_set_relief (GTK_BUTTON (_help_button), GTK_RELIEF_NONE);
    		gtk_container_add (GTK_CONTAINER (_help_button), image);
    		gtk_box_pack_start (GTK_BOX (hbox), _help_button, TRUE, TRUE, 0);
    		g_signal_connect (G_OBJECT (_help_button), "clicked",
    				G_CALLBACK (ui_help_button_click_cb),
    				image);
        }
        
		image = ui_create_hide_icon ();
		_hide_button = gtk_button_new ();
        gtk_widget_modify_bg(_hide_button, GTK_STATE_NORMAL, &_normal_bg);
        gtk_widget_modify_bg(_hide_button, GTK_STATE_PRELIGHT, &_normal_bg);
        gtk_widget_modify_bg(_hide_button, GTK_STATE_ACTIVE, &_normal_bg);

		gtk_button_set_relief (GTK_BUTTON (_hide_button), GTK_RELIEF_NONE);
		gtk_container_add (GTK_CONTAINER (_hide_button), image);
		gtk_box_pack_start (GTK_BOX (hbox), _hide_button, TRUE, TRUE, 0);
		g_signal_connect (G_OBJECT (_hide_button), "clicked",
				G_CALLBACK (ui_turn_off_panel),
				image);

        gtk_window_move (GTK_WINDOW (_toolbar_window), ui_screen_width (), ui_screen_height ());

        gtk_widget_show_all (_toolbar_window);
        gtk_widget_hide (_toolbar_window);

	ui_settle_toolbar_window ();
    }
    //Settle input/lookup windows to default position
    {
        uint32 spot_x, spot_y;

        spot_x = ui_screen_width () / 2 - 64;
        spot_y = ui_screen_height () * 3 / 4;
        gtk_window_move (GTK_WINDOW (_input_window), spot_x, spot_y);

    }

    //Init timeout callback
    if (_toolbar_hide_timeout_max > 0) {
        _toolbar_hide_timeout = gtk_timeout_add (1000, ui_hide_window_timeout_cb, NULL);
        g_signal_connect (G_OBJECT (_toolbar_window), "enter-notify-event",
                          G_CALLBACK (ui_toolbar_window_crossing_cb),
                          GINT_TO_POINTER (0));
        g_signal_connect (G_OBJECT (_toolbar_window), "leave-notify-event",
                          G_CALLBACK (ui_toolbar_window_crossing_cb),
                          GINT_TO_POINTER (1));
    }
}


    // Create help window
    {
        GtkWidget *frame;
        GtkWidget *vbox;

        _help_dialog = gtk_dialog_new_with_buttons (_("SCIM Help"),
                                NULL,
                                GtkDialogFlags (0),
                                GTK_STOCK_OK,
                                GTK_RESPONSE_OK,
                                NULL);

        g_signal_connect_swapped (GTK_OBJECT (_help_dialog), 
                                  "response", 
                                  G_CALLBACK (gtk_widget_hide),
                                  GTK_OBJECT (_help_dialog));

        g_signal_connect_swapped (GTK_OBJECT (_help_dialog), 
                                  "delete_event", 
                                  G_CALLBACK (gtk_widget_hide_on_delete),
                                  GTK_OBJECT (_help_dialog));

        frame = gtk_frame_new (_("Smart Common Input Method"));

        gtk_box_pack_start (GTK_BOX (GTK_DIALOG (_help_dialog)->vbox), frame, TRUE, TRUE, 0);
        gtk_widget_show (frame);

        vbox = gtk_vbox_new (FALSE, 8);
        gtk_container_add (GTK_CONTAINER (frame), vbox);
        gtk_widget_show (vbox);

        _help_scroll = gtk_scrolled_window_new (NULL, NULL);
        gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (_help_scroll), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
        gtk_box_pack_start (GTK_BOX (vbox), _help_scroll, TRUE, TRUE, 0);
        gtk_widget_show (_help_scroll);

        _help_area = gtk_label_new ("");
        gtk_label_set_justify (GTK_LABEL (_help_area), GTK_JUSTIFY_LEFT);
        gtk_scrolled_window_add_with_viewport (GTK_SCROLLED_WINDOW (_help_scroll), _help_area);
        gtk_widget_show (_help_area);
    }

#if ENABLE_TRAY_ICON
    // Create Tray Icon
    {
        if (_show_tray_icon)
            ui_create_tray_icon_when_idle (0);
    }
#endif

    // Init the tooltips
    {
        _tooltips = gtk_tooltips_new ();

        gtk_tooltips_set_delay (_tooltips, 1000);

        if (_help_button)
            gtk_tooltips_set_tip (_tooltips, _help_button,
                                  _("Show a brief help about SCIM and the current input method."),
                                  NULL);

        if (_menu_button)
            gtk_tooltips_set_tip (_tooltips, _menu_button,
                                  _("Show command menu."),
                                  NULL);
    }

#ifdef GDK_WINDOWING_X11
    // Add an event filter function to observe X root window's properties.
    GdkWindow *root_window = gdk_get_default_root_window ();
#if GDK_MULTIHEAD_SAFE
    if (_current_screen)
        root_window = gdk_screen_get_root_window (_current_screen);
#endif
    gdk_window_set_events (root_window, (GdkEventMask)GDK_PROPERTY_NOTIFY);
    gdk_window_add_filter (root_window, ui_event_filter, NULL);
#endif

    _ui_initialized = true;
}

static void
ui_settle_input_window (bool relative, bool force)
{
    SCIM_DEBUG_MAIN (2) << " Settle input window...\n";

    // If we are using VKB, don't do cursor following for input window, and if we are docking panel, then keep it stay at the bottom of screen.
    if (_vkb_embedded) {
        if (_vkb_dock_panel) {
            gint strut_size;
            gtk_window_get_size (GTK_WINDOW (_input_window), &_input_window_width, &_input_window_height);

            gtk_window_move (GTK_WINDOW (_input_window), _workarea_x,
                _workarea_y + _workarea_height - _input_window_height);
	    printf("in function %s input_window_width is %d and it's height is %d\n workarea_x is %d, y is %d\n", __FUNCTION__, _input_window_width, _input_window_height, _workarea_x,_workarea_y + _workarea_height - _input_window_height);

            strut_size = ui_screen_height() - _workarea_y - _workarea_height + _input_window_height;

            if (_panel_strut_size != strut_size) {
                _panel_strut_size = strut_size;
                _scim_panel_vkb_gtk_set_strut(_input_window, _panel_strut_size, _workarea_x,
                                            _workarea_x + _workarea_width);
            }

            return;
        }

        if (force)
	{
	    printf("force is true\n");
            gtk_window_move (GTK_WINDOW (_input_window), _input_window_x, _input_window_y);
	}
        return;
    }

    GtkRequisition ws;
    gint spot_x, spot_y;

    gtk_widget_size_request (_input_window, &ws);

    if (!relative) {
        spot_x = _spot_location_x; 
        spot_y = _spot_location_y; 
	printf("in if function %s spot_x is %d spot_y is %d\n", __FUNCTION__, spot_x, spot_y);
    } else {
        spot_x = _input_window_x; 
        spot_y = _input_window_y;
	printf("in else  function %s spot_x is %d spot_y is %d\n", __FUNCTION__, spot_x, spot_y);
    }

    if (spot_x < 0) spot_x = 0;
    if (spot_y < 0) spot_y = 0;

    if (spot_x + ws.width > ui_screen_width () - 4)
        spot_x = ui_screen_width () - ws.width - 4;
    if (spot_y + ws.height + 8 > ui_screen_height () - 4)
        spot_y = ui_screen_height () - ws.height - 4;

    if (spot_x != _input_window_x || spot_y != _input_window_y || force) {
	printf("aaaaaaaaaaaaaaa\n");
        gtk_window_move (GTK_WINDOW (_input_window), spot_x, spot_y);
        _input_window_x = spot_x;
        _input_window_y = spot_y;
    }
}

static void
ui_settle_toolbar_window (bool force)
{
	if(_vkb_embedded)
			return;
    SCIM_DEBUG_MAIN (2) << " Settle toolbar window...\n";


    gint workarea_x, workarea_y, workarea_width, workarea_height;
    ui_get_workarea (workarea_x, workarea_y, workarea_width, workarea_height);

    GtkRequisition ws;
    gint pos_x, pos_y;

    gtk_widget_size_request (_toolbar_window, &ws);

    pos_x = _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_TOOLBAR_POS_X),
                           workarea_x + workarea_width - ws.width);
    pos_y = _config->read (String (SCIM_CONFIG_PANEL_VKB_GTK_TOOLBAR_POS_Y),
                           workarea_y + workarea_height - ws.height);
    if (pos_x == -1 && pos_y == -1) {
        pos_x = workarea_x + workarea_width  - ws.width;
        pos_y = workarea_y + workarea_height - ws.height;
    }

    if (_toolbar_auto_snap) {
        if ((ui_screen_width () - (pos_x + ws.width)) < pos_x)
            pos_x = ui_screen_width () - ws.width;
        else
            pos_x = 0;
    } else if (pos_x + ws.width > ui_screen_width ()) {
        pos_x = ui_screen_width () - ws.width;
    } else if (pos_x < 0) {
        pos_x = 0;
    }

    if (pos_y + ws.height > ui_screen_height ())
        pos_y = ui_screen_height () - ws.height;
    else if (pos_y < 0)
        pos_y = 0;

    if (_toolbar_window_x != pos_x || _toolbar_window_y != pos_y || force) {
        gtk_window_move (GTK_WINDOW (_toolbar_window), pos_x, pos_y);
        _toolbar_window_x = pos_x;
        _toolbar_window_y = pos_y;
    }
}

static int
ui_screen_width (void)
{
#if GDK_MULTIHEAD_SAFE
    if (_current_screen)
        return gdk_screen_get_width (_current_screen);
#endif
    return gdk_screen_width ();
}

static int
ui_screen_height (void)
{
#if GDK_MULTIHEAD_SAFE
    if (_current_screen)
        return gdk_screen_get_height (_current_screen);
#endif
    return gdk_screen_height ();
}

static void
ui_get_workarea (int &x, int &y, int &width, int &height)
{
    static GdkAtom net_current_desktop_atom = gdk_atom_intern ("_NET_CURRENT_DESKTOP", TRUE);;
    static GdkAtom net_workarea_atom = gdk_atom_intern ("_NET_WORKAREA", TRUE);
    GdkWindow *root_window = gdk_get_default_root_window ();
    GdkAtom atom_ret;
    gint format, length, current_desktop = 0;
    guchar *data;

#if GDK_MULTIHEAD_SAFE
    if (_current_screen)
        root_window = gdk_screen_get_root_window (_current_screen);
#endif

    x = 0;
    y = 0;
    width = ui_screen_width ();
    height = ui_screen_height ();

    if (net_current_desktop_atom != GDK_NONE) {
        gboolean found = gdk_property_get (root_window,
                                           net_current_desktop_atom, GDK_NONE, 0, G_MAXLONG, FALSE,
                                           &atom_ret, &format, &length, &data);
        if (found && format == 32 && length / sizeof(glong) > 0)
            current_desktop = ((glong*)data)[0];
        if (found)
            g_free (data);
    }

    if (net_workarea_atom != GDK_NONE) {
        gboolean found = gdk_property_get (root_window,
                                           net_workarea_atom, GDK_NONE, 0, G_MAXLONG, FALSE,
                                           &atom_ret, &format, &length, &data);
        if (found && format == 32 && (int)(length / sizeof(glong)) >= (current_desktop + 1) * 4) {
            x      = ((glong*)data)[current_desktop * 4];
            y      = ((glong*)data)[current_desktop * 4 + 1];
            width  = ((glong*)data)[current_desktop * 4 + 2];
            height = ((glong*)data)[current_desktop * 4 + 3];
        }
        if (found)
            g_free (data);
    }
}

#if GDK_MULTIHEAD_SAFE
static void
ui_switch_screen (GdkScreen *screen)
{
    if (screen) {
        if (_input_window) {
	    printf(" in function ui_switch_screen \n");
            gtk_window_set_screen (GTK_WINDOW (_input_window), screen);

            _input_window_x = ui_screen_width ();
            _input_window_y = ui_screen_height ();

            gtk_window_move (GTK_WINDOW (_input_window), _input_window_x, _input_window_y);
        }

        if (!_vkb_embedded &&  _toolbar_window) {
            gtk_window_set_screen (GTK_WINDOW (_toolbar_window), screen);
	    ui_settle_toolbar_window ();
        }

#if ENABLE_TRAY_ICON
        if (_tray_icon) {
            gtk_window_set_screen (GTK_WINDOW (_tray_icon), screen);
        }
#endif

        if (_help_dialog) {
            gtk_window_set_screen (GTK_WINDOW (_help_dialog), screen);
        }

#ifdef GDK_WINDOWING_X11
        GdkWindow *root_window = gdk_get_default_root_window ();
        if (_current_screen)
            root_window = gdk_screen_get_root_window (_current_screen);
        gdk_window_set_events (root_window, (GdkEventMask)GDK_PROPERTY_NOTIFY);
        gdk_window_add_filter (root_window, ui_event_filter, NULL);
#endif

        ui_settle_input_window ();
		ui_settle_toolbar_window ();
		}
    }
    }
}
#endif

#if ENABLE_TRAY_ICON
static gboolean
ui_tray_icon_expose_event_cb (GtkWidget *widget, GdkEventExpose *event)
{
    gdk_window_clear_area (widget->window, event->area.x, event->area.y,
                           event->area.width, event->area.height);
    return FALSE;
}

static void
ui_tray_icon_style_set_cb (GtkWidget *widget, GtkStyle *previous_style)
{
    gdk_window_set_back_pixmap (widget->window, NULL, TRUE);
}

static void
ui_tray_icon_realize_cb (GtkWidget *widget)
{
    if (GTK_WIDGET_NO_WINDOW (widget) || GTK_WIDGET_APP_PAINTABLE (widget))
        return;

    gtk_widget_set_app_paintable (widget, TRUE);
    gtk_widget_set_double_buffered (widget, FALSE);
    gdk_window_set_back_pixmap (widget->window, NULL, TRUE);
    g_signal_connect (widget, "expose_event",
                      G_CALLBACK (ui_tray_icon_expose_event_cb), NULL);
    g_signal_connect_after (widget, "style_set",
                            G_CALLBACK (ui_tray_icon_style_set_cb), NULL);
}

static gboolean
ui_create_tray_icon_when_idle (gpointer data)
{
    GtkWidget *image;

    _tray_icon = scim_tray_icon_new ("SCIM Tray Icon");
    g_signal_connect (G_OBJECT (_tray_icon), "realize",
                      G_CALLBACK (ui_tray_icon_realize_cb), NULL);

    _tray_icon_destroy_signal_id = 
    g_signal_connect (G_OBJECT (_tray_icon), "destroy",
                      G_CALLBACK (ui_tray_icon_destroy_cb),
                      0);

    image = ui_create_icon (SCIM_KEYBOARD_ICON_FILE,
                            NULL,
                            TRAY_ICON_SIZE,
                            TRAY_ICON_SIZE,
                            true);

    _tray_icon_factory_button = gtk_event_box_new ();
    g_signal_connect (G_OBJECT (_tray_icon_factory_button), "realize",
                      G_CALLBACK (ui_tray_icon_realize_cb), NULL);
    gtk_container_add (GTK_CONTAINER (_tray_icon_factory_button), image);
    gtk_container_add (GTK_CONTAINER (_tray_icon), _tray_icon_factory_button);
    g_signal_connect (G_OBJECT (_tray_icon_factory_button), "button-release-event",
                      G_CALLBACK (ui_factory_button_released_cb),
                      0);

    gtk_widget_show_all (GTK_WIDGET (_tray_icon));

    return FALSE;
}
#endif

static GdkPixbuf *
ui_scale_pixbuf (GdkPixbuf *pixbuf,
                 int        width,
                 int        height)
{
    if (pixbuf) {
        if (gdk_pixbuf_get_width (pixbuf) != width ||
            gdk_pixbuf_get_height (pixbuf) != height) {
            GdkPixbuf *dest = gdk_pixbuf_scale_simple (pixbuf, width, height, GDK_INTERP_BILINEAR);
            g_object_unref (pixbuf);
            pixbuf = dest;
        }
    }
    return pixbuf;
}

static GtkWidget *
ui_create_label (const String   &name,
                 const String   &iconfile,
                 const char    **xpm,
                 bool            show_icon_only,
                 bool            force_icon)
{
    GtkWidget * hbox = gtk_hbox_new (FALSE, 0);
    GtkWidget * label = gtk_label_new (name.c_str ());

    gint width, height;

    if (_default_font_desc)
        gtk_widget_modify_font (label, _default_font_desc);

    gtk_widget_modify_fg(label, GTK_STATE_NORMAL, &_normal_text);
    gtk_widget_modify_fg(label, GTK_STATE_PRELIGHT, &_normal_text);
    gtk_widget_modify_fg(label, GTK_STATE_ACTIVE, &_normal_text);

    //gtk_icon_size_lookup (GTK_ICON_SIZE_MENU, &width, &height);
    if(_vkb_embedded) {
        width = TOOLBAR_ICON_SIZE;
        height = TOOLBAR_ICON_SIZE;
    } else { 
        width = SMALL_TOOLBAR_ICON_SIZE;
        height = SMALL_TOOLBAR_ICON_SIZE;
    }

    GtkWidget *icon = ui_create_icon (iconfile,
                                      xpm,
                                      width,
                                      height,
                                      force_icon);

    if (icon) {
        gtk_box_pack_start (GTK_BOX (hbox), icon, FALSE, FALSE, 0);
        if (!show_icon_only)
	{
            gtk_box_set_spacing (GTK_BOX (hbox), 4);

	}
    }

    if (!show_icon_only || !icon)
        gtk_box_pack_start (GTK_BOX (hbox), label, FALSE, FALSE, 0);
    else
        gtk_widget_destroy (label);

    gtk_widget_show_all (hbox);

    return hbox;
}

static GtkWidget *
ui_create_icon (const String  &iconfile,
                const char   **xpm,
                int            width,
                int            height,
                bool           force_create)
{
    String path = iconfile;
    GdkPixbuf *pixbuf = 0;

    if (path.length ()) {
        // Not a absolute path, prepend SCIM_ICONDIR
        if (path [0] != SCIM_PATH_DELIM)
            path = String (SCIM_ICONDIR) + String (SCIM_PATH_DELIM_STRING) + path;

        pixbuf = gdk_pixbuf_new_from_file (path.c_str (), 0);
    }

    if (!pixbuf && xpm) {
        pixbuf = gdk_pixbuf_new_from_xpm_data (xpm);
    }

    if (!pixbuf && force_create) {
        if (width <= 0 || height <= 0)
            return 0;

        pixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB, true, 8, width, height);

        if (!pixbuf)
            return 0;

        gdk_pixbuf_fill (pixbuf, 0);
    }

    if (pixbuf) {
        if (width <= 0) width = gdk_pixbuf_get_width (pixbuf);
        if (height <= 0) height = gdk_pixbuf_get_height (pixbuf);

        pixbuf = ui_scale_pixbuf (pixbuf, width, height);

        GtkWidget *icon = gtk_image_new_from_pixbuf (pixbuf);
        gtk_widget_show (icon);

        gdk_pixbuf_unref (pixbuf);

        return icon;
    }
    return 0;
}

static GtkWidget *
ui_create_trademark_icon (void)
{
	if(_vkb_embedded)
	{
		return ui_create_icon (SCIM_TRADEMARK_ICON_FILE,
				(const char **) trademark_xpm,
				TOOLBAR_ICON_SIZE + 4,
				TOOLBAR_ICON_SIZE + 4);
	}
	else
	{
		return ui_create_icon (SCIM_TRADEMARK_ICON_FILE,
				(const char **) trademark_xpm,
				SMALL_TOOLBAR_ICON_SIZE + 4,
				SMALL_TOOLBAR_ICON_SIZE + 4);
	}
}


static GtkWidget *
ui_create_help_icon (void)
{
	if(_vkb_embedded)
	{
		return ui_create_icon (SCIM_HELP_ICON_FILE,
				(const char **) help_xpm,
				TOOLBAR_ICON_SIZE,
				TOOLBAR_ICON_SIZE);
	}
	else
	{
		return ui_create_icon (SCIM_HELP_ICON_FILE,
				(const char **) help_xpm,
				SMALL_TOOLBAR_ICON_SIZE,
				SMALL_TOOLBAR_ICON_SIZE);
	}
}

static GtkWidget *
ui_create_hide_icon (void)
{
	if(_vkb_embedded)
	{
		return ui_create_icon (SCIM_HIDE_ICON_FILE,
				(const char **) hide_xpm,
				TOOLBAR_ICON_SIZE,
				TOOLBAR_ICON_SIZE);
	}
	else
	{
		return ui_create_icon (SCIM_HIDE_ICON_FILE,
				(const char **) hide_xpm,
				SMALL_TOOLBAR_ICON_SIZE,
				SMALL_TOOLBAR_ICON_SIZE);
	}
}

static GtkWidget *
ui_create_menu_icon (void)
{
	if(_vkb_embedded)
	{
		return ui_create_icon (SCIM_MENU_ICON_FILE,
				(const char **) menu_xpm,
				TOOLBAR_ICON_SIZE,
				TOOLBAR_ICON_SIZE);
	}
	else
	{
		return ui_create_icon (SCIM_MENU_ICON_FILE,
				(const char **) menu_xpm,
				SMALL_TOOLBAR_ICON_SIZE,
				SMALL_TOOLBAR_ICON_SIZE);
	}
}

static GtkWidget *
ui_create_left_icon (void)
{
	if(_vkb_embedded)
	{
		return ui_create_icon (SCIM_LEFT_ICON_FILE,
				(const char **) left_xpm,
				LOOKUP_ICON_SIZE,
				LOOKUP_ICON_SIZE);
	}
	else
	{
		return ui_create_icon (SCIM_LEFT_ICON_FILE,
				(const char **) left_xpm,
				SMALL_LOOKUP_ICON_SIZE,
				SMALL_LOOKUP_ICON_SIZE);
	}
}

static GtkWidget *
ui_create_right_icon (void)
{
	if(_vkb_embedded)
	{
		return ui_create_icon (SCIM_RIGHT_ICON_FILE,
				(const char **) right_xpm,
				LOOKUP_ICON_SIZE,
				LOOKUP_ICON_SIZE);
	}
	else
	{
		return ui_create_icon (SCIM_RIGHT_ICON_FILE,
				(const char **) right_xpm,
				SMALL_LOOKUP_ICON_SIZE,
				SMALL_LOOKUP_ICON_SIZE);
	}
}
/*
static GtkWidget*
ui_create_factory_menu_entry (const PanelFactoryInfo &info,
                              gint                   id,
                              GtkMenuShell           *menu,
                              bool                   show_lang,
                              bool                   show_name)
{
    gint width, height;
    GtkWidget *menu_item;
    GtkWidget *icon_image;
    String text, tooltip;

    if (show_lang && !show_name) {
        text = scim_get_language_name (info.lang);
        tooltip = info.name;
    } else if (!show_lang && show_name) {
        text = info.name;
        tooltip = "";
    } else {
        text = scim_get_language_name (info.lang) + " -// " + info.name;
        tooltip = "";
    }

    menu_item = gtk_image_menu_item_new_with_label (text.c_str ());
    //menu_item = gtk_image_menu_item_new_with_label ("aaaaa");
    gtk_icon_size_lookup (GTK_ICON_SIZE_MENU, &width, &height);
    icon_image = ui_create_icon (info.icon, NULL, width, height, false);
    if (icon_image)
        gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (menu_item), icon_image);

    g_signal_connect (G_OBJECT (menu_item), "activate",
                      G_CALLBACK (ui_factory_menu_activate_cb),
                      GINT_TO_POINTER ((gint)id));
    gtk_widget_show (menu_item);

    gtk_menu_shell_append (GTK_MENU_SHELL (menu), menu_item);

    if (tooltip != "")
        gtk_tooltips_set_tip (_tooltips, menu_item, tooltip.c_str (), NULL);

    return menu_item;
}
*/
/* Implementation of callback functions */
static void
ui_preedit_area_move_cursor_cb (ScimStringView *view,
                                guint           position)
{
    SCIM_DEBUG_MAIN (3) << "  ui_preedit_area_move_cursor_cb...\n";

    _panel_agent->move_preedit_caret (position);
}

static void
ui_help_button_click_cb (GtkButton *button,
                         gpointer   user_data)
{
    SCIM_DEBUG_MAIN (3) << "  ui_help_button_click_cb...\n";

    if (GTK_WIDGET_VISIBLE (_help_dialog)) {
        gtk_widget_hide (_help_dialog);
    } else {
        action_request_help ();
    }
}

static void
ui_menu_button_click_cb (GtkButton *button,
                         gpointer   user_data)
{
    SCIM_DEBUG_MAIN (3) << "  ui_menu_button_click_cb...\n";

    struct timeval cur_time;
    gettimeofday (&cur_time, 0);

    if (cur_time.tv_sec < _last_menu_deactivate_time.tv_sec ||
        (cur_time.tv_sec == _last_menu_deactivate_time.tv_sec &&
         cur_time.tv_usec < _last_menu_deactivate_time.tv_usec + 200000))
        return;

    action_show_command_menu ();
}

/*
static gboolean
ui_factory_button_click_cb (GtkWidget *button,
                            gpointer   user_data)
{
    printf("in ui_factory_button_clicked_cb     \n");
    SCIM_DEBUG_MAIN (3) << "  ui_factory_button_click_cb...\n";

    struct timeval cur_time;
    gettimeofday (&cur_time, 0);

    if (cur_time.tv_sec < _last_menu_deactivate_time.tv_sec ||
        (cur_time.tv_sec == _last_menu_deactivate_time.tv_sec &&
         cur_time.tv_usec < _last_menu_deactivate_time.tv_usec + 200000))
        return FALSE;

     //_panel_agent->request_factory_menu ();

    return FALSE;
}
*/
/*
static gboolean
ui_factory_button_click_cb(GtkWidget *button,
			   gpointer user_data)
{
     _panel_agent->request_factory_menu ();
        _panel_agent->change_factory (_factory_menu_uuids [0]);
    return FALSE;


}
*/
static gboolean
ui_factory_button_released_cb (GtkWidget *button,
                            GdkEvent  *event,
                            gpointer   user_data)
{
    SCIM_DEBUG_MAIN (3) << "  ui_factory_button_released_cb...\n";

    GdkEventButton *bevent = (GdkEventButton *) event;

    struct timeval cur_time;
    gettimeofday (&cur_time, 0);

    if (cur_time.tv_sec < _last_menu_deactivate_time.tv_sec ||
        (cur_time.tv_sec == _last_menu_deactivate_time.tv_sec &&
         cur_time.tv_usec < _last_menu_deactivate_time.tv_usec + 200000))
        return FALSE;

    if (bevent->button <= 1)
        _panel_agent->request_factory_menu ();
    else
        action_show_command_menu ();

    return FALSE;
}
/*
static void
ui_factory_menu_activate_cb (GtkMenuItem *item,
                             gpointer     user_data)
{
    int id = GPOINTER_TO_INT (user_data);

    if (id >= 0 && id < (int) _factory_menu_uuids.size ())
    {
        _panel_agent->change_factory (_factory_menu_uuids [id]);
	printf("ffffffffffffffffffff\n");
	std::cerr<<_factory_menu_uuids[0];
    }
    else
        _panel_agent->change_factory ("");
}*/
/*
static void
ui_factory_menu_deactivate_cb (GtkMenuItem *item,
                               gpointer     user_data)
{
    _factory_menu_activated = false;
    gettimeofday (&_last_menu_deactivate_time, 0);
}
*/
static void
ui_lookup_table_horizontal_click_cb (GtkWidget *item,
                                     guint      position)
{
    SCIM_DEBUG_MAIN (3) << "  ui_lookup_table_horizontal_click_cb...\n";

    int *index = _lookup_table_index;
    int pos = (int) position;

    for (int i=0; i<SCIM_LOOKUP_TABLE_MAX_PAGESIZE && index [i] >= 0; ++i) {
        if (pos >= index [i] && pos < index [i+1]) {
            _panel_agent->select_candidate ((uint32) i);
            return;
        }
    }
}

static gboolean
ui_toolbar_window_crossing_cb (GtkWidget        *window,
                               GdkEventCrossing *event,
                               gpointer          user_data)
{
    if ( _panel_is_on || _toolbar_window_draging)
        return FALSE;

    int crossing_type = GPOINTER_TO_INT (user_data);

    // 0 == enter, otherwise leave
    if (crossing_type == 0) {
        if (_toolbar_hidden) {
            if (_factory_button)
                gtk_widget_show (_factory_button);

            if (_client_properties_area)
                gtk_widget_show (_client_properties_area);

            if (_menu_button)
                gtk_widget_show (_menu_button);

            if (_help_button)
                gtk_widget_show (_help_button);

            if (_hide_button)
                gtk_widget_show (_hide_button);

            _toolbar_hidden = false;
            ui_settle_toolbar_window ();
        }
        _toolbar_should_hide = false;
    } else {
        _toolbar_should_hide = true;
    }

    return FALSE;
}

static gboolean
ui_toolbar_window_motion_cb (GtkWidget *window,
                             GdkEventMotion *event,
                             gpointer user_data)
{
    gint pos_x, pos_y;
    if ((event->state & (GDK_BUTTON1_MASK | GDK_BUTTON2_MASK | GDK_BUTTON3_MASK)) != 0 &&
        _toolbar_window_draging) {
        gtk_window_get_position (GTK_WINDOW (window), &pos_x, &pos_y);
        gtk_window_move (GTK_WINDOW (window),
            pos_x + ((gint) event->x_root - _toolbar_window_drag_x),
            pos_y + ((gint) event->y_root - _toolbar_window_drag_y));

        _toolbar_window_drag_x = (gint) event->x_root;
        _toolbar_window_drag_y = (gint) event->y_root;

        return TRUE;
    }
    return FALSE;
}

static gboolean
ui_toolbar_window_click_cb (GtkWidget *window,
                            GdkEventButton *event,
                            gpointer user_data)
{
    int click_type = GPOINTER_TO_INT (user_data);
    static gulong motion_handler;
    GdkCursor *cursor;

    if (click_type == 0 && event->button <= 1) {
        if (_toolbar_window_draging)
            return FALSE;

        // Connection pointer motion handler to this window.
        motion_handler = g_signal_connect (G_OBJECT (window), "motion-notify-event",
                                           G_CALLBACK (ui_toolbar_window_motion_cb),
                                           NULL);

        _toolbar_window_draging = TRUE;
        _toolbar_window_drag_x = (gint) event->x_root;
        _toolbar_window_drag_y = (gint) event->y_root;

        cursor = gdk_cursor_new (GDK_TOP_LEFT_ARROW);

        // Grab the cursor to prevent losing events.
        gdk_pointer_grab (window->window, TRUE,
                          (GdkEventMask) (GDK_BUTTON_RELEASE_MASK | GDK_POINTER_MOTION_MASK),
                          NULL, cursor, event->time);
        gdk_cursor_unref (cursor);
        return TRUE;
    } else if (click_type == 1 && event->button <= 1) {
        if (!_toolbar_window_draging)
            return FALSE;

        g_signal_handler_disconnect (G_OBJECT (window), motion_handler);
        gdk_pointer_ungrab (event->time);
        _toolbar_window_draging = FALSE;

        gint pos_x, pos_y;

        gtk_window_get_position (GTK_WINDOW (window), &pos_x, &pos_y);

        if (!_config.null () &&
            (_toolbar_window_x != pos_x || _toolbar_window_y != pos_y)) {
            _config->write (
                SCIM_CONFIG_PANEL_VKB_GTK_TOOLBAR_POS_X, pos_x);
            _config->write (
                SCIM_CONFIG_PANEL_VKB_GTK_TOOLBAR_POS_Y, pos_y);

        }
        _toolbar_window_x = pos_x;
        _toolbar_window_y = pos_y;

        return TRUE;
    } else if (click_type == 1 && event->button > 1) {
        action_show_command_menu ();
        return TRUE;
    }
    return FALSE;
}

static void
ui_lookup_table_up_button_click_cb (GtkButton *button,
                                    gpointer user_data)
{
    SCIM_DEBUG_MAIN (3) << "  ui_lookup_table_up_button_click_cb...\n";

    _panel_agent->lookup_table_page_up ();
}

static void
ui_lookup_table_down_button_click_cb (GtkButton *button,
                                      gpointer user_data)
{
    SCIM_DEBUG_MAIN (3) << "  ui_lookup_table_down_button_click_cb...\n";

    _panel_agent->lookup_table_page_down ();
}

static gboolean
ui_input_window_motion_cb (GtkWidget *window,
                           GdkEventMotion *event,
                           gpointer user_data)
{
    gint pos_x, pos_y;

    if ((event->state & (GDK_BUTTON1_MASK | GDK_BUTTON2_MASK | GDK_BUTTON3_MASK)) != 0 &&
        _input_window_draging) {
        gtk_window_get_position (GTK_WINDOW (window), &pos_x, &pos_y);
        gtk_window_move (GTK_WINDOW (window), 
            pos_x + ((gint) event->x_root - _input_window_drag_x),
            pos_y + ((gint) event->y_root - _input_window_drag_y));

        _input_window_drag_x = (gint) event->x_root;
        _input_window_drag_y = (gint) event->y_root;

        return TRUE;
    }
    return FALSE;
}

static gboolean
ui_input_window_click_cb (GtkWidget *window,
                          GdkEventButton *event,
                          gpointer user_data)
{
    int click_type = GPOINTER_TO_INT (user_data);
    static gulong motion_handler;
    GdkCursor *cursor;

    if (click_type == 0) {
        if (_input_window_draging)
            return FALSE;

        // Connection pointer motion handler to this window.
        motion_handler = g_signal_connect (G_OBJECT (window), "motion-notify-event",
                                           G_CALLBACK (ui_input_window_motion_cb),
                                           NULL);

        _input_window_draging = TRUE;
        _input_window_drag_x = (gint) event->x_root;
        _input_window_drag_y = (gint) event->y_root;

        cursor = gdk_cursor_new (GDK_TOP_LEFT_ARROW);
    
        // Grab the cursor to prevent losing events.
        gdk_pointer_grab (window->window, TRUE,
                          (GdkEventMask) (GDK_BUTTON_RELEASE_MASK | GDK_POINTER_MOTION_MASK),
                          NULL, cursor, event->time);
        gdk_cursor_unref (cursor);
        return TRUE;
    } else if (click_type == 1) {
        if (!_input_window_draging)
            return FALSE;

        g_signal_handler_disconnect (G_OBJECT (window), motion_handler);
        gdk_pointer_ungrab (event->time);
        _input_window_draging = FALSE;

        gtk_window_get_position (GTK_WINDOW (window), &_input_window_x, &_input_window_y);

        return TRUE;
    }

    return FALSE;
}

static gboolean
ui_hide_window_timeout_cb (gpointer data)
{
    gdk_threads_enter ();


    if (!_toolbar_should_hide || _panel_is_on ||
        _toolbar_window_draging || _toolbar_hidden ||
        ui_any_menu_activated ()) {
        _toolbar_hide_timeout_count = 0;
        gdk_threads_leave ();
        return TRUE;
    }

    _toolbar_hide_timeout_count ++;

    if (_toolbar_hide_timeout_count > _toolbar_hide_timeout_max) {
        _toolbar_hide_timeout_count = 0;

        if (_help_button)
            gtk_widget_hide (_help_button);

        if (_menu_button)
            gtk_widget_hide (_menu_button);

        if (_client_properties_area)
            gtk_widget_hide (_client_properties_area);

        if (_factory_button)
            gtk_widget_hide (_factory_button);

        _toolbar_hidden = true;
        ui_settle_toolbar_window ();
    }

    gdk_threads_leave ();
    return TRUE;
}

static bool
ui_can_hide_input_window (void)
{
    if (!_panel_is_on) return true;

    if ((_vkb_embedded && GTK_WIDGET_VISIBLE (_vkb_window)))
        return false;
    return true;
}

static bool
ui_any_menu_activated (void)
{
    return _factory_menu_activated || _command_menu_activated || _property_menu_activated;
}

static void
ui_show_help (const String &help)
{
    if (!help.length () || !_help_dialog || !_help_scroll || !_help_area)
        return;

    GtkRequisition size;

    gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (_help_scroll), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);

    gtk_label_set_text (GTK_LABEL (_help_area), help.c_str ());

    gtk_widget_size_request (_help_area, &size);

    if (size.width > ui_screen_width ()/2) {
        size.width = ui_screen_width ()/2;
        gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (_help_scroll), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
    }

    if (size.height > ui_screen_height ()/2)
        size.height = ui_screen_height ()/2;

    if (size.height < size.width/2)
        size.height = size.width/2;

    gtk_widget_set_size_request (_help_scroll, size.width, size.height);

    gtk_window_set_position (GTK_WINDOW (_help_dialog), GTK_WIN_POS_CENTER_ALWAYS);
    gtk_widget_show (_help_dialog);
}

static void
ui_show_vkb_window (void)
{
    if (!_vkb_embedded)
        return;

    gtk_widget_show (_vkb_window);

    if (_panel_is_on && !GTK_WIDGET_VISIBLE (_input_window)) {
	printf("in ui_show_vkb_window\n");
        gtk_widget_show (_input_window);
        ui_settle_input_window (true, true);
    }
}

static void
ui_hide_vkb_window (void)
{
    if (!_vkb_embedded)
        return;

    gtk_widget_hide (_vkb_window);

    if (ui_can_hide_input_window ())
        gtk_widget_hide (_input_window);
}

static PangoAttrList *
create_pango_attrlist (const String        &mbs,
                       const AttributeList &attrs)
{
    PangoAttrList  *attrlist = pango_attr_list_new ();
    PangoAttribute *attr;

    guint start_index, end_index;
    guint wlen = g_utf8_strlen (mbs.c_str (), mbs.length ());

    for (int i=0; i < (int) attrs.size (); ++i) {
        start_index = attrs[i].get_start ();
        end_index = attrs[i].get_end ();

        if (end_index <= wlen && start_index < end_index) {
            start_index = g_utf8_offset_to_pointer (mbs.c_str (), attrs[i].get_start ()) - mbs.c_str ();
            end_index = g_utf8_offset_to_pointer (mbs.c_str (), attrs[i].get_end ()) - mbs.c_str ();

            if (attrs[i].get_type () == SCIM_ATTR_DECORATE) {
                if (attrs[i].get_value () == SCIM_ATTR_DECORATE_UNDERLINE) {
                    attr = pango_attr_underline_new (PANGO_UNDERLINE_SINGLE);
                    attr->start_index = start_index;
                    attr->end_index = end_index;
                    pango_attr_list_insert (attrlist, attr);
                } else if (attrs[i].get_value () == SCIM_ATTR_DECORATE_REVERSE) {
                    attr = pango_attr_foreground_new (_normal_bg.red, _normal_bg.green, _normal_bg.blue);
                    attr->start_index = start_index;
                    attr->end_index = end_index;
                    pango_attr_list_insert (attrlist, attr);

                    attr = pango_attr_background_new (_normal_text.red, _normal_text.green, _normal_text.blue);
                    attr->start_index = start_index;
                    attr->end_index = end_index;
                    pango_attr_list_insert (attrlist, attr);
                } else if (attrs[i].get_value () == SCIM_ATTR_DECORATE_HIGHLIGHT) {
                    attr = pango_attr_foreground_new (_active_text.red, _active_text.green, _active_text.blue);
                    attr->start_index = start_index;
                    attr->end_index = end_index;
                    pango_attr_list_insert (attrlist, attr);

                    attr = pango_attr_background_new (_active_bg.red, _active_bg.green, _active_bg.blue);
                    attr->start_index = start_index;
                    attr->end_index = end_index;
                    pango_attr_list_insert (attrlist, attr);
                }
            } else if (attrs[i].get_type () == SCIM_ATTR_FOREGROUND) {
                unsigned int color = attrs[i].get_value ();

                attr = pango_attr_foreground_new (SCIM_RGB_COLOR_RED(color) * 256, SCIM_RGB_COLOR_GREEN(color) * 256, SCIM_RGB_COLOR_BLUE(color) * 256);
                attr->start_index = start_index;
                attr->end_index = end_index;
                pango_attr_list_insert (attrlist, attr);
            } else if (attrs[i].get_type () == SCIM_ATTR_BACKGROUND) {
                unsigned int color = attrs[i].get_value ();

                attr = pango_attr_background_new (SCIM_RGB_COLOR_RED(color) * 256, SCIM_RGB_COLOR_GREEN(color) * 256, SCIM_RGB_COLOR_BLUE(color) * 256);
                attr->start_index = start_index;
                attr->end_index = end_index;
                pango_attr_list_insert (attrlist, attr);
            }
        }
    }
    return attrlist;
}

static void
ui_command_menu_reload_activate_cb (GtkMenuItem *item,
                                    gpointer     user_data)
{
    _panel_agent->reload_config ();

    if (!_config.null ()) _config->reload ();
}

static void
ui_command_menu_help_activate_cb (GtkMenuItem *item,
                                  gpointer     user_data)
{
    if (GTK_WIDGET_VISIBLE (_help_dialog)) {
        gtk_widget_hide (_help_dialog);
    } else {
        action_request_help ();
    }
}

static void
ui_command_menu_helper_activate_cb (GtkWidget *item,
                                    gpointer   user_data)
{
    size_t i = (size_t) GPOINTER_TO_INT (user_data);

    if (i < _helper_list.size ())
        _panel_agent->start_helper (_helper_list [i].uuid);
}

static void
ui_command_menu_deactivate_cb (GtkWidget   *item,
                               gpointer     user_data)
{
    _command_menu_activated = false;
    gettimeofday (&_last_menu_deactivate_time, 0);
}

#if ENABLE_TRAY_ICON
static void
ui_tray_icon_destroy_cb (GtkObject      *object,
                         gpointer        user_data)
{
    SCIM_DEBUG_MAIN (1) << "Tray Icon destroyed!\n";

    gtk_widget_destroy (GTK_WIDGET (object));

    _tray_icon = 0;
    _tray_icon_factory_button = 0;

    g_idle_add (ui_create_tray_icon_when_idle, NULL);
}
#endif

static void
ui_property_activate_cb (GtkWidget      *widget,
                         gpointer        user_data)
{
    GtkWidget *submenu = (GtkWidget *) g_object_get_data (G_OBJECT (widget), "property_submenu");

    if (submenu) {
#if GDK_MULTIHEAD_SAFE
        if (_current_screen)
            gtk_menu_set_screen (GTK_MENU (submenu), _current_screen);
#endif
        guint32 activate_time = gtk_get_current_event_time ();
        _property_menu_activated = true;
        gtk_menu_popup (GTK_MENU (submenu), 0, 0, 0, 0, 1, activate_time);
        return;
    }

    gchar * key = (gchar *) g_object_get_data (G_OBJECT (widget), "property_key");

    if (key) {
        int client = GPOINTER_TO_INT (user_data);

        if (client < 0)
            _panel_agent->trigger_property (key);
        else
            _panel_agent->trigger_helper_property (client, key);
    }
}

static void
ui_property_menu_deactivate_cb (GtkWidget   *item,
                                gpointer     user_data)
{
    printf("in ui_property_menu_deactivate_cb\n");
    _property_menu_activated = false;
}

//Implementation of the action functions
static void
action_request_help (void)
{
    if (!_panel_agent->request_help ()) {
        String help;

        help =  String (_("Smart Common Input Method platform ")) +
                String (SCIM_VERSION) +
                String (_("\n(C) 2002-2005 James Su <suzhe@tsinghua.org.cn>"));

        ui_show_help (help);
    }
}

static void
action_show_command_menu (void)
{
    if (_command_menu_activated)
        return;

    _command_menu_activated = true;

    guint32 activate_time = gtk_get_current_event_time ();

    if (_command_menu) {
        gtk_widget_destroy (_command_menu);
        _command_menu = 0;
    }

    _command_menu = gtk_menu_new ();

#if GDK_MULTIHEAD_SAFE
    if (_current_screen)
        gtk_menu_set_screen (GTK_MENU (_command_menu), _current_screen);
#endif

    GtkWidget *menu_item;
    GtkWidget *icon;

    gint width, height;

    gtk_icon_size_lookup (GTK_ICON_SIZE_MENU, &width, &height);

    // Add Helper object items.
    for (size_t i = 0; i < _helper_list.size (); ++i) {
        if ((_helper_list [i].option & SCIM_HELPER_STAND_ALONE) != 0 &&
            (_helper_list [i].option & SCIM_HELPER_AUTO_START) == 0) {
            menu_item = gtk_image_menu_item_new_with_label (_helper_list [i].name.c_str ());
            gtk_tooltips_set_tip (_tooltips, menu_item, _helper_list [i].description.c_str (), NULL);
            icon = ui_create_icon (_helper_list [i].icon, NULL, width, height, false);

            if (icon)
                gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (menu_item), icon);

            gtk_menu_shell_append (GTK_MENU_SHELL (_command_menu), menu_item);

            g_signal_connect (G_OBJECT (menu_item), "activate",
                              G_CALLBACK (ui_command_menu_helper_activate_cb),
                              GINT_TO_POINTER ((int)i));

            gtk_widget_show (menu_item);
        }
    }

    if (_helper_list.size ()) {
        menu_item = gtk_separator_menu_item_new ();
        gtk_menu_shell_append (GTK_MENU_SHELL (_command_menu), menu_item);
        gtk_widget_show (menu_item);
    }

    //Reload Configuration.
    menu_item = gtk_image_menu_item_new_with_label (_("Reload Configuration"));
    gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (menu_item),
                                   gtk_image_new_from_stock (GTK_STOCK_REFRESH, GTK_ICON_SIZE_MENU));
    gtk_menu_shell_append (GTK_MENU_SHELL (_command_menu), menu_item);
    g_signal_connect (G_OBJECT (menu_item), "activate",
                      G_CALLBACK (ui_command_menu_reload_activate_cb),
                      0);
    gtk_widget_show_all (menu_item);

     //Help
    menu_item = gtk_image_menu_item_new_with_label (_("Help ..."));
    gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (menu_item),
                                   gtk_image_new_from_stock (GTK_STOCK_HELP, GTK_ICON_SIZE_MENU));
    gtk_menu_shell_append (GTK_MENU_SHELL (_command_menu), menu_item);
    g_signal_connect (G_OBJECT (menu_item), "activate",
                      G_CALLBACK (ui_command_menu_help_activate_cb),
                      0);
    gtk_widget_show_all (menu_item);

    g_signal_connect (G_OBJECT (_command_menu), "deactivate",
                      G_CALLBACK (ui_command_menu_deactivate_cb),
                      NULL);

    gtk_menu_popup (GTK_MENU (_command_menu), 0, 0, 0, 0, 2, activate_time);
}

//////////////////////////////////////////////////////////////////////
// Start of PanelAgent Functions
//////////////////////////////////////////////////////////////////////
static bool
initialize_panel_agent (const String &config, const String &display, bool resident)
{
    _panel_agent = new PanelAgent ();

    if (!_panel_agent->initialize (config, display, resident))
        return false;

    _panel_agent->signal_connect_transaction_start          (slot (slot_transaction_start));
    _panel_agent->signal_connect_transaction_end            (slot (slot_transaction_end));
    _panel_agent->signal_connect_reload_config              (slot (slot_reload_config));
    _panel_agent->signal_connect_turn_on                    (slot (slot_turn_on));
    _panel_agent->signal_connect_turn_off                   (slot (slot_turn_off));
    _panel_agent->signal_connect_update_screen              (slot (slot_update_screen));
    _panel_agent->signal_connect_update_spot_location       (slot (slot_update_spot_location));
    _panel_agent->signal_connect_update_factory_info        (slot (slot_update_factory_info));
    _panel_agent->signal_connect_show_help                  (slot (slot_show_help));
    _panel_agent->signal_connect_show_factory_menu          (slot (slot_show_factory_menu));
    _panel_agent->signal_connect_show_preedit_string        (slot (slot_show_preedit_string));
    _panel_agent->signal_connect_show_aux_string            (slot (slot_show_aux_string));
    _panel_agent->signal_connect_show_lookup_table          (slot (slot_show_lookup_table));
    _panel_agent->signal_connect_hide_preedit_string        (slot (slot_hide_preedit_string));
    _panel_agent->signal_connect_hide_aux_string            (slot (slot_hide_aux_string));
    _panel_agent->signal_connect_hide_lookup_table          (slot (slot_hide_lookup_table));
    _panel_agent->signal_connect_update_preedit_string      (slot (slot_update_preedit_string));
    _panel_agent->signal_connect_update_preedit_caret       (slot (slot_update_preedit_caret));
    _panel_agent->signal_connect_update_aux_string          (slot (slot_update_aux_string));
    _panel_agent->signal_connect_update_lookup_table        (slot (slot_update_lookup_table));
    _panel_agent->signal_connect_register_properties        (slot (slot_register_properties));
    _panel_agent->signal_connect_update_property            (slot (slot_update_property));
    _panel_agent->signal_connect_register_helper_properties (slot (slot_register_helper_properties));
    _panel_agent->signal_connect_update_helper_property     (slot (slot_update_helper_property));
    _panel_agent->signal_connect_register_helper            (slot (slot_register_helper));
    _panel_agent->signal_connect_remove_helper              (slot (slot_remove_helper));
    _panel_agent->signal_connect_lock                       (slot (slot_lock));
    _panel_agent->signal_connect_unlock                     (slot (slot_unlock));

    _panel_agent->get_helper_list (_helper_list);

    return true;
}

static bool
run_panel_agent (void)
{
    SCIM_DEBUG_MAIN(1) << "run_panel_agent ()\n";

    _panel_agent_thread = NULL;

    if (_panel_agent && _panel_agent->valid ())
        _panel_agent_thread = g_thread_create (panel_agent_thread_func, NULL, TRUE, NULL);

    return (_panel_agent_thread != NULL);
}

static gpointer
panel_agent_thread_func (gpointer data)
{
    SCIM_DEBUG_MAIN(1) << "panel_agent_thread_func ()\n";

    if (!_panel_agent->run ())
        std::cerr << "Failed to run Panel.\n";

    G_LOCK (_global_resource_lock);
    _should_exit = true;
    G_UNLOCK (_global_resource_lock);

    g_thread_exit (NULL);
    return ((gpointer) NULL);
}

static void
start_auto_start_helpers (void)
{
    SCIM_DEBUG_MAIN(1) << "start_auto_start_helpers ()\n";

    // Add Helper object items.
    for (size_t i = 0; i < _helper_list.size (); ++i) {
        if ((_helper_list [i].option & SCIM_HELPER_AUTO_START) != 0) {
            _panel_agent->start_helper (_helper_list [i].uuid);
        }
    }
}

static void
slot_transaction_start (void)
{
    gdk_threads_enter ();
}

static void
slot_transaction_end (void)
{
    gdk_threads_leave ();
}

static void
slot_reload_config (void)
{
    if (!_config.null ()) _config->reload ();
}

static void
slot_real_turn_on (void)
{
//    printf("in function slot_real_turn_on\n");
    _toolbar_should_hide = false;
    _toolbar_hidden = false;
    _panel_is_on = true;

    gtk_widget_hide (_lookup_table_window);

    ui_show_vkb_window();

	if(_vkb_is_alone && _vkb_embedded)
	{
	} else {
	    gtk_widget_show (_aux_area);
    }
	    
    if (_frontend_properties_area)
        gtk_widget_hide (_frontend_properties_area);

    if (_factory_button)
        gtk_widget_show (_factory_button);

    if (_client_properties_area)
        gtk_widget_show (_client_properties_area);

    if (_menu_button)
        gtk_widget_show (_menu_button);

    if (_help_button)
        gtk_widget_show (_help_button);

    if (_toolbar_window)
        gtk_widget_show (_toolbar_window);

}

static void
slot_real_turn_off (void)
{
//    printf("in slot_real_turn_off function\n");
//    if (ui_any_menu_activated ()) return;

    _panel_is_on = false;

    gtk_widget_hide (_input_window);
    gtk_widget_hide (_lookup_table_window);

    gtk_widget_hide (_aux_area);

    ui_hide_vkb_window ();

    if (_frontend_properties_area)
        gtk_widget_hide (_frontend_properties_area);

    if (_toolbar_window) {
        if (!_toolbar_hidden) {
			gtk_widget_hide (_toolbar_window);
			_toolbar_hidden = true;
		}
    } else {
        gtk_widget_hide (_toolbar_window);
        _toolbar_hidden = true;
    }
}

gboolean slot_triger_cb (gboolean *on)
{
//    printf("in %s _panel_is_on is %d\n",__FUNCTION__, _panel_is_on);
    if (*on == _panel_is_on)
        goto done;

    if (*on)
        slot_real_turn_on();
    else
        slot_real_turn_off();

done:
    triger_delay_timeout_id = 0;

    return FALSE;
}

static void
slot_turn_on (void)
{
//    printf("in %s \n",__FUNCTION__);
    if (triger_delay_timeout_id != 0)
        g_source_remove(triger_delay_timeout_id);

    triger_on = TRUE;
    triger_delay_timeout_id = g_timeout_add(triger_delay,
        (GSourceFunc)slot_triger_cb, &triger_on);

	if(!_vkb_embedded)
	{
		_toolbar_should_hide = false;
		_toolbar_hidden = false;
		_panel_is_on = true;

		gtk_widget_hide (_lookup_table_window);
		gtk_widget_hide (_input_window);
		gtk_widget_hide (_preedit_area);
		gtk_widget_hide (_aux_area);

		if (_frontend_properties_area)
			gtk_widget_hide (_frontend_properties_area);

		if (_factory_button)
			gtk_widget_show (_factory_button);

		if (_client_properties_area)
			gtk_widget_show (_client_properties_area);

		if (_menu_button)
			gtk_widget_show (_menu_button);

		if (_help_button)
			gtk_widget_show (_help_button);

		if (_toolbar_window)
			gtk_widget_show (_toolbar_window);

		ui_settle_toolbar_window (true);
	}
}

static void
slot_turn_off (void)
{
    //printf("in %s \n",__FUNCTION__);
    if (triger_delay_timeout_id != 0)
        g_source_remove(triger_delay_timeout_id);

    triger_on = FALSE;
    triger_delay_timeout_id = g_timeout_add(triger_delay,
        (GSourceFunc)slot_triger_cb, &triger_on);

}

static void
slot_update_screen (int num)
{
#if GDK_MULTIHEAD_SAFE
    if (gdk_display_get_n_screens (gdk_display_get_default ()) > num) {

        GdkScreen *screen = gdk_display_get_screen (gdk_display_get_default (), num);

        if (screen) {
#ifdef GDK_WINDOWING_X11
            GdkWindow *root_window = gdk_get_default_root_window ();
            if (_current_screen)
                root_window = gdk_screen_get_root_window (_current_screen);
            gdk_window_remove_filter (root_window, ui_event_filter, NULL);
#endif

            _current_screen = screen;
            ui_switch_screen (screen);
        }
    }
#endif
}

static void
slot_update_factory_info (const PanelFactoryInfo &info)
{
    //printf("---------- slot_update_factory_info\n");
    if (_factory_button) {
        GtkWidget * newlabel = 0;

        if (_toolbar_show_factory_icon) {
//	    printf("in qqqqqqqqqqqqqqq slot_update_factory_info\n");
         /*   newlabel = ui_create_label (info.name,
                                        info.icon,
                                        0,
                                        !_toolbar_show_factory_name,
                                        false);*/
            newlabel = gtk_label_new ("");
        } else {
            newlabel = gtk_label_new (info.name.c_str ());
            if (_default_font_desc)
                gtk_widget_modify_font (newlabel, _default_font_desc);

            gtk_widget_modify_fg(newlabel, GTK_STATE_NORMAL, &_normal_text);
            gtk_widget_modify_fg(newlabel, GTK_STATE_PRELIGHT, &_normal_text);
            gtk_widget_modify_fg(newlabel, GTK_STATE_ACTIVE, &_normal_text);
            gtk_widget_show (newlabel);
        }

        if (newlabel) {
            GtkWidget * old = gtk_bin_get_child (GTK_BIN (_factory_button));
            if (old)
                gtk_container_remove (GTK_CONTAINER (_factory_button), old);
            gtk_container_add (GTK_CONTAINER (_factory_button), newlabel);
//	    printf("in else qqqqqqqqqqqqqqq slot_update_factory_info\n");
        }

        if (!GTK_WIDGET_VISIBLE (_factory_button) && !_toolbar_hidden)
            gtk_widget_show (_factory_button);

        //if (_tooltips)
        if (0)
            gtk_tooltips_set_tip (_tooltips, _factory_button, info.name.c_str (), NULL);

			ui_settle_toolbar_window ();
    }

#if ENABLE_TRAY_ICON
    if (_tray_icon_factory_button) {
        GtkWidget *icon = gtk_bin_get_child (GTK_BIN (_tray_icon_factory_button));

        if (icon)
            gtk_container_remove (GTK_CONTAINER (_tray_icon_factory_button), icon);

        icon = ui_create_icon (info.icon, NULL, TRAY_ICON_SIZE, TRAY_ICON_SIZE, true);

        gtk_container_add (GTK_CONTAINER (_tray_icon_factory_button), icon);

        if (_tooltips)
            gtk_tooltips_set_tip (_tooltips, _tray_icon_factory_button, info.name.c_str (), NULL);
    }
#endif

    if (info.uuid != "") {
        _recent_factory_uuids.remove(info.uuid);
        _recent_factory_uuids.push_front(info.uuid);
        if (_recent_factory_uuids.size () > 5)
            _recent_factory_uuids.pop_back ();
    }
}

static void
slot_show_help (const String &help)
{
    ui_show_help (help);
}
/*
static void
slot_show_factory_menu (const std::vector <PanelFactoryInfo> &factories)
{
    if (!_factory_menu_activated && factories.size ()) {
        size_t i;

        MapStringVectorSizeT groups;
        std::map<String,size_t> recents;

        //guint32 activate_time = gtk_get_current_event_time ();

        _factory_menu_uuids.clear ();
        _factory_menu_activated = true;

        bool use_submenus = false;
        bool show_recent = (factories.size () > 5 && _recent_factory_uuids.size ());

        for (i = 0; i < factories.size (); ++i) {
            _factory_menu_uuids.push_back (factories [i].uuid);

            if (show_recent &&
                std::find (_recent_factory_uuids.begin (), _recent_factory_uuids.end (),
                           factories [i].uuid) != _recent_factory_uuids.end ()) {
                recents [factories [i].uuid] = i;
            } else {
                groups [factories [i].lang].push_back (i);
                if (groups [factories [i].lang].size () > 1)
                    use_submenus = true;
            }
        }

        use_submenus = (use_submenus && factories.size () > 9);

        if (_factory_menu) {
            gtk_widget_destroy (_factory_menu);
            _factory_menu = 0;
        }

        _factory_menu = gtk_menu_new ();

#if GDK_MULTIHEAD_SAFE
    if (_current_screen)
        gtk_menu_set_screen (GTK_MENU (_factory_menu), _current_screen);
#endif

        GtkWidget *submenu;
        GtkWidget *menu_item;
        guint id;
        PanelFactoryInfo info;

        // recently used factories
        if (show_recent && recents.size ()) {
            for (std::list<String>::iterator it = _recent_factory_uuids.begin (); it != _recent_factory_uuids.end (); ++it) {
                id = recents [*it];
                info = factories [id];

                ui_create_factory_menu_entry (info, id, GTK_MENU_SHELL (_factory_menu), true, true);

                if (use_submenus) {
                    MapStringVectorSizeT::iterator g = groups.find (info.lang);
                    if (g != groups.end () && g->second.size () >= 1) {
                        g->second.push_back (id);
                        use_submenus = true;
                    }
                }
            }

            menu_item = gtk_separator_menu_item_new ();
            gtk_menu_shell_append (GTK_MENU_SHELL (_factory_menu), menu_item);
            gtk_widget_show (menu_item);
        }

        for (MapStringVectorSizeT::iterator it = groups.begin (); it != groups.end (); ++ it) {
            if (use_submenus && it->second.size () > 1) {
                String lang = it->first;
                menu_item = gtk_menu_item_new_with_label (scim_get_language_name (lang).c_str ());
                submenu = gtk_menu_new ();
            } else {
                menu_item = 0;
                submenu = 0;
            }

            for (i = 0; i < it->second.size (); ++i) {
                id = it->second [i];
                info = factories [id];
                ui_create_factory_menu_entry (info, id, GTK_MENU_SHELL (submenu ? submenu : _factory_menu), !submenu, submenu || !use_submenus);
            }

            if (menu_item && submenu) {
                gtk_menu_shell_append (GTK_MENU_SHELL (_factory_menu), menu_item);
                gtk_widget_show (menu_item);
                gtk_menu_item_set_submenu (GTK_MENU_ITEM (menu_item), submenu);
                gtk_widget_show (submenu);
            }
        }

        //Append an entry for forward mode.
        info = PanelFactoryInfo (String (""), String ("English/Keyboarda"), String ("C"), String (SCIM_KEYBOARD_ICON_FILE));
        //ui_create_factory_menu_entry (info, -1, GTK_MENU_SHELL (_factory_menu), false, true);

        g_signal_connect (G_OBJECT (_factory_menu), "deactivate",
                          G_CALLBACK (ui_factory_menu_deactivate_cb),
                          NULL);
        //gtk_menu_popup (GTK_MENU (_factory_menu), 0, 0, 0, 0, 1, activate_time);
    }
}
*/
static void
slot_show_factory_menu (const std::vector <PanelFactoryInfo> &factories)
{
    if (!_factory_menu_activated && factories.size ()) {
        size_t i;

        _factory_menu_uuids.clear ();
        _factory_menu_activated = true;


        for (i = 0; i < factories.size (); ++i) {
            _factory_menu_uuids.push_back (factories [i].uuid);

    }
    }
}

static void
slot_update_spot_location (int x, int y)
{
    if (x > 0 && x < ui_screen_width () && y > 0 && y < ui_screen_height ()) {
        _spot_location_x = x;
        _spot_location_y = y;

//        ui_settle_input_window ();
	printf("thhis is in function %s x is %d y is %d\n", __FUNCTION__, _spot_location_x, _spot_location_y);
    }
}

static void
slot_show_preedit_string (void)
{
	printf("thhis is in function %s\n", __FUNCTION__);
    gtk_widget_show (_preedit_area);

    if (_panel_is_on && !GTK_WIDGET_VISIBLE (_input_window))
        gtk_widget_show (_input_window);

    ui_settle_input_window (true, true);
}

static void
slot_show_aux_string (void)
{
	printf("thhis is in function %s\n", __FUNCTION__);
    gtk_widget_show (_aux_area);

    if (_panel_is_on && !GTK_WIDGET_VISIBLE (_input_window))
        gtk_widget_show (_input_window);

    ui_settle_input_window (true, true);
}

static void
slot_show_lookup_table (void)
{
    gtk_widget_show_all (_lookup_table_window);
	if(_vkb_embedded)
		gtk_widget_hide (_toolbar_window);

    if (_panel_is_on && !GTK_WIDGET_VISIBLE (_input_window)) {
	printf("thhis is in function %s\n", __FUNCTION__);
        gtk_widget_show (_input_window);
        ui_settle_input_window (true, true);
    }
}

static void
slot_hide_preedit_string (void)
{
    //gtk_widget_hide (_preedit_area);
    //scim_string_view_set_text (SCIM_STRING_VIEW (_preedit_area), "");

    if (ui_can_hide_input_window ())
        gtk_widget_hide (_input_window);
}

static void
slot_hide_aux_string (void)
{
    scim_string_view_set_text (SCIM_STRING_VIEW (_aux_area), "");

    if (ui_can_hide_input_window ())
        gtk_widget_hide (_input_window);
}

static void
slot_hide_lookup_table (void)
{
    gtk_widget_hide (_lookup_table_window);
    gtk_widget_show (_toolbar_window);

    if (ui_can_hide_input_window ())
        gtk_widget_hide (_input_window);
}

static void
slot_update_preedit_string (const String &str, const AttributeList &attrs)
{
    PangoAttrList  *attrlist = create_pango_attrlist (str, attrs);

    scim_string_view_set_attributes (SCIM_STRING_VIEW (_preedit_area), attrlist);
    scim_string_view_set_text (SCIM_STRING_VIEW (_preedit_area), str.c_str ());

    pango_attr_list_unref (attrlist);

	printf("thhis is in function %s\n", __FUNCTION__);
    ui_settle_input_window (true);
}

static void
slot_update_preedit_caret (int caret)
{
    scim_string_view_set_position (SCIM_STRING_VIEW (_preedit_area), caret);
}

static void
slot_update_aux_string (const String &str, const AttributeList &attrs)
{
    PangoAttrList  *attrlist = create_pango_attrlist (str, attrs);

    scim_string_view_set_attributes (SCIM_STRING_VIEW (_aux_area), attrlist);
   scim_string_view_set_text (SCIM_STRING_VIEW (_aux_area), str.c_str ());

    pango_attr_list_unref (attrlist);

	printf("thhis is in function %s\n", __FUNCTION__);
    ui_settle_input_window (true);
}

static void
slot_update_lookup_table (const LookupTable &table)
{
    int i;
    int item_num = table.get_current_page_size ();

    String         mbs;
    WideString     wcs;
    WideString     label;
    GtkRequisition size;
    AttributeList  attrs;
    PangoAttrList  *attrlist;

    {
        int max_length;

        if (_vkb_embedded) {
            max_length = _lookup_table_width;
        } else
            max_length = ui_screen_width () / 2;

        _lookup_table_index [0] = 0;
        for (i=0; i<SCIM_LOOKUP_TABLE_MAX_PAGESIZE; ++i) {
            if (i<item_num) {
                // Update attributes
                AttributeList item_attrs = table.get_attributes_in_current_page (i);
                size_t attr_start, attr_end;

                if (_vkb_embedded) {
                    label = WideString ();
                } else {
                    label = table.get_candidate_label (i);
                    if (label.length ()) {
                        label += utf8_mbstowcs (".");
                    }
                }

                wcs += label;

                attr_start = wcs.length ();

                wcs += table.get_candidate_in_current_page (i);

                attr_end = wcs.length ();

                wcs.push_back (0x20);

                _lookup_table_index [i+1] = wcs.length ();

                mbs = utf8_wcstombs (wcs);

                scim_string_view_set_text (SCIM_STRING_VIEW (_lookup_table_items [0]),
                                           mbs.c_str ());

                gtk_widget_size_request (_lookup_table_window, &size);

                if (size.width >= max_length && !table.is_page_size_fixed ()) {
                    item_num = i+1;
                }

                if (item_attrs.size ()) {
                    for (AttributeList::iterator ait = item_attrs.begin (); ait != item_attrs.end (); ++ait) {
                        ait->set_start (ait->get_start () + attr_start);
                        if (ait->get_end () + attr_start > attr_end)
                            ait->set_length (attr_end - ait->get_start ());
                    }

                    attrs.insert (attrs.end (), item_attrs.begin (), item_attrs.end ());
                }

            } else {
                _lookup_table_index [i+1] = -1;
            }
        }

        if (attrs.size ()) {
            attrlist = create_pango_attrlist (mbs, attrs);
            scim_string_view_set_attributes (SCIM_STRING_VIEW (_lookup_table_items [0]), attrlist);
            pango_attr_list_unref (attrlist);
        } else {
            scim_string_view_set_attributes (SCIM_STRING_VIEW (_lookup_table_items [0]), 0);
        }

        if (table.is_cursor_visible ()) {
            int start = _lookup_table_index [table.get_cursor_pos_in_current_page ()];
            int end = _lookup_table_index [table.get_cursor_pos_in_current_page ()+1] - 1;
            scim_string_view_set_highlight (SCIM_STRING_VIEW (_lookup_table_items [0]), start, end);
        } else {
            scim_string_view_set_highlight (SCIM_STRING_VIEW (_lookup_table_items [0]), -1, -1);
        }
    }

    if (table.get_current_page_start ())
        gtk_widget_set_sensitive (_lookup_table_up_button, TRUE);
    else
        gtk_widget_set_sensitive (_lookup_table_up_button, FALSE);

    if (table.get_current_page_start () + item_num < (int)table.number_of_candidates ())
        gtk_widget_set_sensitive (_lookup_table_down_button, TRUE);
    else
        gtk_widget_set_sensitive (_lookup_table_down_button, FALSE);

    if (item_num < table.get_current_page_size ())
        _panel_agent->update_lookup_table_page_size (item_num);

	printf("thhis is in function %s\n", __FUNCTION__);
    ui_settle_input_window (true);
}

static void
slot_register_properties (const PropertyList &props)
{
    register_frontend_properties (props);
}

static void
slot_update_property (const Property &prop)
{
    update_frontend_property (prop);
}

static void
slot_register_helper_properties (int id, const PropertyList &props)
{
    register_helper_properties (id, props);
}

static void
slot_update_helper_property (int id, const Property &prop)
{
    update_helper_property (id, prop);
}

static void
slot_register_helper (int id, const HelperInfo &helper)
{
}

static void
slot_remove_helper (int id)
{
    HelperPropertyRepository::iterator it = _helper_property_repository.find (id);

    if (it != _helper_property_repository.end () && it->second.holder)
        gtk_widget_destroy (it->second.holder);

    _helper_property_repository.erase (id);
}

static void
slot_lock (void)
{
    G_LOCK (_panel_agent_lock);
}

static void
slot_unlock (void)
{
    G_UNLOCK (_panel_agent_lock);
}
//////////////////////////////////////////////////////////////////////
// End of PanelAgent-Functions
//////////////////////////////////////////////////////////////////////

static GtkWidget *
create_properties_node (PropertyRepository           &repository,
                        PropertyList::const_iterator  begin,
                        PropertyList::const_iterator  end,
                        int                           client,
                        int                           level)
{
    PropertyList::const_iterator it;
    PropertyList::const_iterator next;

    GtkWidget * node;
    PropertyInfo info;
    bool leaf = true;

    if (begin >= end) return 0;

    // If the level is zero, then create the this node as button, otherwise create as a menu item.
    if (!level) {
        GtkWidget * label = ui_create_label (begin->get_label (),
                                             begin->get_icon (),
                                             0,
                                             !_toolbar_show_property_label,
                                             false);

        node = gtk_button_new ();
        gtk_widget_modify_bg(node, GTK_STATE_NORMAL, &_normal_bg);
        gtk_widget_modify_bg(node, GTK_STATE_PRELIGHT, &_normal_bg);
        gtk_widget_modify_bg(node, GTK_STATE_ACTIVE, &_normal_bg);

        gtk_container_add (GTK_CONTAINER (node), label);
        gtk_button_set_relief (GTK_BUTTON (node), GTK_RELIEF_NONE);
    } else {
        gint width, height;
        gtk_icon_size_lookup (GTK_ICON_SIZE_MENU, &width, &height);
        GtkWidget * icon = ui_create_icon (begin->get_icon (), NULL, width, height, false);
        node = gtk_image_menu_item_new_with_label (begin->get_label ().c_str ());
        if (icon)
            gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (node), icon);
    }

    if (begin->visible ())
        gtk_widget_show (node);
    else
        gtk_widget_hide (node);

    gtk_widget_set_sensitive (node, begin->active ());

    if (_tooltips && begin->get_tip ().length ())
        gtk_tooltips_set_tip (_tooltips, node, begin->get_tip ().c_str (), NULL);

    g_object_set_data_full (G_OBJECT (node), "property_key", g_strdup (begin->get_key ().c_str ()), g_free);

    info.property = *begin;
    info.widget = node;

    repository.push_back (info);

    it = begin + 1;

    if (it != end) {
        GtkWidget * submenu = gtk_menu_new ();
        GtkWidget * child;
        int menu_item_idx = 0;

        // Create all leafs of the first child.
        while (it != end) {
            // Find all leafs of the first child.
            for (next = it + 1; next != end; ++ next)
                if (!next->is_a_leaf_of (*it)) break;

            child = create_properties_node (repository, it, next, client, level + 1);
            if (child) {
                gtk_menu_shell_append (GTK_MENU_SHELL (submenu), child);
                g_object_set_data (G_OBJECT (child), "menu_item_idx", GINT_TO_POINTER (menu_item_idx));
                ++ menu_item_idx;
            }

            it = next;
        }

        // The node is a button, so attach the submenu as its data.
        if (!level) {
            g_object_set_data_full (G_OBJECT (node), "property_submenu", submenu, (void (*)(void*)) gtk_widget_destroy);

            g_signal_connect (G_OBJECT (submenu), "deactivate",
                              G_CALLBACK (ui_property_menu_deactivate_cb),
                              NULL);
        } else // The node is a menu item, so attach the submenu directly.
            gtk_menu_item_set_submenu (GTK_MENU_ITEM (node), submenu);

        leaf = false;
    }

    if (leaf || level == 0) {
        g_signal_connect (G_OBJECT (node),
                          ((level > 0) ? "activate" : "clicked"),
                          G_CALLBACK (ui_property_activate_cb),
                          GINT_TO_POINTER (client));
    }

    return node;
}

static void
create_properties (GtkWidget *container,
                   PropertyRepository &repository,
                   const PropertyList &properties,
                   int client,
                   int level)
{

    PropertyList::const_iterator it;
    PropertyList::const_iterator next;
    PropertyList::const_iterator begin = properties.begin ();
    PropertyList::const_iterator end = properties.end ();

    GtkWidget *root;

    int menu_item_idx = 0;

    if (begin == end) return;

    root = gtk_hbox_new (FALSE, 0);

    it = begin;
    next = begin + 1;

    while (it != end) {
        if (next == end || !next->is_a_leaf_of (*it)) {
            GtkWidget * node = create_properties_node (repository, it, next, client, level);

            if (node) {
                // The container is a hbox.
                if (!level)
                    gtk_box_pack_start (GTK_BOX (container), node, TRUE, TRUE, 0);
                // The container is a menu.
                else {
                    gtk_menu_shell_append (GTK_MENU_SHELL (container), node);
                    g_object_set_data (G_OBJECT (node), "menu_item_idx", GINT_TO_POINTER (menu_item_idx));
                    ++ menu_item_idx;
                }
            }
            it = next;
        }
        ++ next;
    }
}

static void
register_frontend_properties (const PropertyList &properties)
{
    bool same = true;

    PropertyList::const_iterator pit = properties.begin ();

    if (properties.size () == 0) {
        same = false;
    } else if (properties.size () == _frontend_property_repository.size ()) {
        // Check if the properties are same as old ones.
        PropertyRepository::iterator it = _frontend_property_repository.begin ();

        for (; it != _frontend_property_repository.end (); ++it, ++pit) {
            if (it->property != *pit) {
                same = false;
                break;
            }
        }
    } else {
        same = false;
    }

    // Only update the properties.
    if (same) {
        for (pit = properties.begin (); pit != properties.end (); ++pit)
            update_frontend_property (*pit);

        gtk_widget_show (_frontend_properties_area);
    } else { // Construct all properties.
        if (_frontend_properties_area)
            gtk_widget_destroy (_frontend_properties_area);

        _frontend_properties_area = 0;

        _frontend_property_repository.clear ();

        if (properties.size ()) {
            _frontend_properties_area = gtk_hbox_new (FALSE, 0);

            create_properties (_frontend_properties_area,
                               _frontend_property_repository,
                               properties,
                               -1,
                               0);

            gtk_widget_show (_frontend_properties_area);

            //gtk_box_pack_start (GTK_BOX (_client_properties_area), _frontend_properties_area, TRUE,TRUE, 0);
        }
    }

}

static void
update_frontend_property (const Property &property)
{
    update_property (_frontend_property_repository, property);
}

static void
register_helper_properties (int client, const PropertyList &properties)
{
    HelperPropertyRepository::iterator it = _helper_property_repository.find (client);

    if (it == _helper_property_repository.end ()) {
        _helper_property_repository [client] = HelperPropertyInfo ();
        it = _helper_property_repository.find (client);
    }

    if (it->second.holder)
        gtk_widget_destroy (it->second.holder);

    it->second.holder = 0;

    if (properties.size ()) {
        it->second.holder = gtk_hbox_new (FALSE, 0);

        create_properties (it->second.holder,
                           it->second.repository,
                           properties,
                           client,
                           0);

        gtk_widget_show (it->second.holder);
        //gtk_box_pack_end (GTK_BOX (_client_properties_area), it->second.holder, TRUE,TRUE, 0);
    }

}

static void
update_helper_property (int client, const Property &property)
{
    update_property (_helper_property_repository [client].repository, property);
}

static void
update_property (PropertyRepository &repository,
                 const Property       &property)
{
    PropertyRepository::iterator it = repository.begin ();

    for (; it != repository.end (); ++ it) {
        if (it->property == property) {

            if (!it->widget) break;

            if (it->property.get_label () != property.get_label () ||
                it->property.get_icon () != property.get_icon ()) {
                if (GTK_IS_BUTTON (it->widget)) {
                    GtkWidget *label = ui_create_label (property.get_label (),
                                                        property.get_icon (),
                                                        0,
                                                        !_toolbar_show_property_label,
                                                        false);
                    GtkWidget *old = gtk_bin_get_child (GTK_BIN (it->widget));
                    gtk_container_remove (GTK_CONTAINER (it->widget), old);
                    gtk_container_add (GTK_CONTAINER (it->widget), label);
                } else if (GTK_IS_MENU_ITEM (it->widget)) {
                    gint width, height;
                    gtk_icon_size_lookup (GTK_ICON_SIZE_MENU, &width, &height);

                    GtkWidget * menu = gtk_widget_get_parent (it->widget);
                    int menu_item_idx = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (it->widget), "menu_item_idx"));

                    GtkWidget * icon = ui_create_icon (property.get_icon (), NULL, width, height, false);
                    GtkWidget * new_item = gtk_image_menu_item_new_with_label (property.get_label ().c_str ());

                    gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (new_item), icon);

                    GtkWidget * submenu = gtk_menu_item_get_submenu (GTK_MENU_ITEM (it->widget));

                    gtk_menu_item_set_submenu (GTK_MENU_ITEM (new_item), submenu);

                    g_object_set_data_full (G_OBJECT (new_item), "property_key", g_strdup (property.get_key ().c_str ()), g_free);
                    g_object_set_data (G_OBJECT (new_item), "menu_item_idx", GINT_TO_POINTER (menu_item_idx));

                    gtk_widget_destroy (it->widget);

                    it->widget = new_item;
                    gtk_menu_shell_insert (GTK_MENU_SHELL (menu), new_item, menu_item_idx);
                }
            }

            if (property.visible ())
                gtk_widget_show (it->widget);
            else
                gtk_widget_hide (it->widget);

            gtk_widget_set_sensitive (it->widget, property.active ());

            if (_tooltips && property.get_tip ().length ())
                gtk_tooltips_set_tip (_tooltips, it->widget, property.get_tip ().c_str (), NULL);

            it->property = property;
            break;
        }
    }
}

static void
restore_properties (void)
{
    PropertyList properties;

    _frontend_properties_area = 0;

    PropertyRepository::iterator it = _frontend_property_repository.begin ();
    HelperPropertyRepository::iterator helper_it = _helper_property_repository.begin ();

    for (; it != _frontend_property_repository.end (); ++it)
        properties.push_back (it->property);

    if (properties.size ()) {
        _frontend_property_repository.clear ();
        register_frontend_properties (properties);
    }

    for (; helper_it != _helper_property_repository.end (); ++ helper_it) {

        helper_it->second.holder = 0;

        properties.clear ();

        for (it = helper_it->second.repository.begin (); it != helper_it->second.repository.end (); ++it)
            properties.push_back (it->property);

        if (properties.size ()) {
            helper_it->second.repository.clear ();
            register_helper_properties (helper_it->first, properties);
        }
    }
}

static gboolean
check_exit_timeout_cb (gpointer data)
{
    G_LOCK (_global_resource_lock);
    if (_should_exit) {
        gdk_threads_enter ();
        gtk_main_quit ();
        gdk_threads_leave ();
    }
    G_UNLOCK (_global_resource_lock);

    return TRUE;
}

static void
signalhandler(int sig)
{
    SCIM_DEBUG_MAIN (1) << "In signal handler...\n";

    if (_panel_agent != NULL) {
        _panel_agent->stop ();
    }

    if (VKB_PID)
        kill (VKB_PID, SIGTERM);  /* kill VKB process  */
    exit (0);
}

int main (int argc, char *argv [])
{
    std::vector<String>  config_list;

    int i;

    bool daemon = false;

    int    new_argc = 0;
    char **new_argv = new char * [40];

    String config_name ("simple");
    String display_name;
    bool should_resident = true;

    //dbus object
    PanelVkbDbusObj* dbusobj = NULL;
    ComposeKeyFactory factory;
    //disabled IME list
    std::vector <String> disabled;
    std::vector<String>::iterator f_it;

    setlocale (LC_ALL, "");
    bindtextdomain (PACKAGE, LOCALEDIR);
    textdomain(PACKAGE);

    //Display version info
    std::cerr << "GTK Panel of SCIM " << SCIM_VERSION << "\n\n";

    //get modules list
    scim_get_config_module_list (config_list);

    //Add a dummy config module, it's not really a module!
    config_list.push_back ("dummy");

    //Use socket Config module as default if available.
    if (config_list.size ()) {
        if (std::find (config_list.begin (),
                       config_list.end (),
                       config_name) == config_list.end ())
            config_name = config_list [0];
    }

    DebugOutput::disable_debug (SCIM_DEBUG_AllMask);
    DebugOutput::enable_debug (SCIM_DEBUG_MainMask);

    //parse command options
    i = 0;
    while (i<argc) {
        if (++i >= argc) break;

        if (String ("-l") == argv [i] ||
            String ("--list") == argv [i]) {
            std::vector<String>::iterator it;

            std::cout << "\n";
            std::cout << "Available Config module:\n";
            for (it = config_list.begin (); it != config_list.end (); it++)
                std::cout << "    " << *it << "\n";

            return 0;
        }

        if (String ("-c") == argv [i] ||
            String ("--config") == argv [i]) {
            if (++i >= argc) {
                std::cerr << "no argument for option " << argv [i-1] << "\n";
                return -1;
            }
            config_name = argv [i];
            continue;
        }

        if (String ("-h") == argv [i] ||
            String ("--help") == argv [i]) {
            std::cout << "Usage: " << argv [0] << " [option]...\n\n"
                 << "The options are: \n"
                 << "  --display DISPLAY    Run on display DISPLAY.\n"
                 << "  -l, --list           List all of available config modules.\n"
                 << "  -c, --config NAME    Uses specified Config module.\n"
                 << "  -d, --daemon         Run " << argv [0] << " as a daemon.\n"
                 << "  -ns, --no-stay       Quit if no connected client.\n"
#if ENABLE_DEBUG
                 << "  -v, --verbose LEVEL  Enable debug info, to specific LEVEL.\n"
                 << "  -o, --output FILE    Output debug information into FILE.\n"
#endif
                 << "  -h, --help           Show this help message.\n";
            return 0;
        }

        if (String ("-d") == argv [i] ||
            String ("--daemon") == argv [i]) {
            daemon = true;
            continue;
        }

        if (String ("-ns") == argv [i] ||
            String ("--no-stay") == argv [i]) {
            should_resident = false;
            continue;
        }

        if (String ("-v") == argv [i] ||
            String ("--verbose") == argv [i]) {
            if (++i >= argc) {
                std::cerr << "no argument for option " << argv [i-1] << "\n";
                return -1;
            }
            DebugOutput::set_verbose_level (atoi (argv [i]));
            continue;
        }

        if (String ("-o") == argv [i] ||
            String ("--output") == argv [i]) {
            if (++i >= argc) {
                std::cerr << "No argument for option " << argv [i-1] << "\n";
                return -1;
            }
            DebugOutput::set_output (argv [i]);
            continue;
        }

        if (String ("--display") == argv [i]) {
            if (++i >= argc) {
                std::cerr << "No argument for option " << argv [i-1] << "\n";
                return -1;
            }
            display_name = argv [i]; 
            continue;
        }

        if (String ("--") == argv [i])
            break;

        std::cerr << "Invalid command line option: " << argv [i] << "\n";
        return -1;
    } //End of command line parsing.

    new_argv [new_argc ++] = argv [0];

    // Store the rest argvs into new_argv.
    for (++i; i < argc && new_argc < 40; ++i) {
        new_argv [new_argc ++] = argv [i];
    }

    // Make up DISPLAY env.
    if (display_name.length ()) {
        new_argv [new_argc ++] = const_cast <char*> ("--display");
        new_argv [new_argc ++] = const_cast <char*> (display_name.c_str ());

        setenv ("DISPLAY", display_name.c_str (), 1);
    }

    new_argv [new_argc] = 0;

    if (!config_name.length ()) {
        std::cerr << "No Config module is available!\n";
        return -1;
    }

    //Check whether IME "English/European" is disabled, if yes,
    //enable it(this is the default IME for VKB, and so can not be disabled)
    disabled = scim_global_config_read (String (SCIM_GLOBAL_CONFIG_DISABLED_IMENGINE_FACTORIES), disabled);
    if((f_it = std::find(disabled.begin(), disabled.end(), String(factory.get_uuid()))) != disabled.end())
    {
        disabled.erase(f_it);
        scim_global_config_write (String (SCIM_GLOBAL_CONFIG_DISABLED_IMENGINE_FACTORIES), disabled);
    }

    if (config_name != "dummy") {
        //load config module
        _config_module = new ConfigModule (config_name);

        if (!_config_module || !_config_module->valid ()) {
            std::cerr << "Can not load " << config_name << " Config module.\n";
            return -1;
        }

        //create config instance
        _config = _config_module->create_config ();
    } else {
        _config = new DummyConfig ();
    }

    if (_config.null ()) {
        std::cerr << "Failed to create Config instance from "
             << config_name << " Config module.\n";
        return -1;
    }

    /*init dbus interface*/
    dbusobj = panel_vkb_dbus_init();

    /* init threads */
    g_thread_init (NULL);
    gdk_threads_init ();

    signal(SIGQUIT, signalhandler);
    signal(SIGTERM, signalhandler);
    signal(SIGINT,  signalhandler);
    signal(SIGHUP,  signalhandler);

    gtk_init (&new_argc, &new_argv);

    ui_initialize ();

    // get current display.
    {
#if GDK_MULTIHEAD_SAFE
        const char *p = gdk_display_get_name (gdk_display_get_default ());
#else
        const char *p = getenv ("DISPLAY");
#endif
        if (p) display_name = String (p);
    }

    if (!initialize_panel_agent (config_name, display_name, should_resident)) {
        std::cerr << "Failed to initialize Panel Agent!\n";
        return -1;
    }
 
    if (daemon)
        scim_daemon ();

    // connect the configuration reload signal.
    _config->signal_connect_reload (slot (ui_config_reload_callback));

    if (!run_panel_agent()) {
        std::cerr << "Failed to run Socket Server!\n";
        return -1;
    }

    start_auto_start_helpers ();

    _check_exit_timeout = gtk_timeout_add (10000, check_exit_timeout_cb, NULL);

    gdk_threads_enter ();
    gtk_main ();
    gdk_threads_leave ();

    // Exiting...
    g_thread_join (_panel_agent_thread);
    _config.reset ();

    std::cerr << "Successfully exited.\n";

    return 0;
}
static
void  ui_turn_off_panel(GtkButton  *button, gpointer  user_data)
{
	printf("in ui_turn_off_panel\n");
    _panel_agent->change_factory ("");
    slot_real_turn_off();
}

/*
vi:ts=4:nowrap:expandtab
*/

